<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBXCC6C989805C34BCB86A76800A275B81D">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">InfiltrationEngine-PrefabSystem</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Script" referent="RBX6A213352F5024A24A45EF2B05240F2D9">
			<Properties>
				<ProtectedString name="Source"><![CDATA[local warnLogger = require(script.Parent.Slogger).init{
	postInit = table.freeze,
	logFunc = warn
}

local warn = warnLogger.new("PrefabSystem")

local glut = require(script.Parent.GLUt)
glut.configure{ warn = warn }

local apiConsumer = require(script.Parent.APIConsumer)

local luaExpr = require(script.Parent.LuaExpr)
local luaExprFuncs = require(script.Parent.LuaExprFuncs)
local exprRules = luaExpr.MakeEvalRules("%$%(", "%)")

type APIReference = apiConsumer.APIReference

local hookName = nil
local API_ID = "InfiltrationEngine-PrefabSystem"

local prefabSystem = {}

local function CheckArgCountRange(fname, expectedMin, expectedMax, ...)
	local argCount = select('#', ...)
	if argCount < expectedMin or argCount > expectedMax then
		local expected = (expectedMin == expectedMax) and expectedMin-2 or `{expectedMin-2}-{expectedMax-2}`
		error(`{fname} expects {expected} arguments, but got {argCount}!`)
	end
end

local function CheckArgCount(fname, expected, ...) CheckArgCountRange(fname, expected, expected, ...) end

local PREFAB_IDS = {}
local ELEMENT_IDS = {}

local function GetId(tbl, inst)
	local existing = tbl[inst]
	if existing ~= nil then return existing end
	
	local max = tbl.Total or 0
	tbl[inst] = max
	tbl.Total = max + 1
	return max
end

local function strKeySub(str, key, value)
	key = tostring(key)
	value = tostring(value)
	return string.gsub(str, "([^{]){" .. key .. "}([^}])", function(d1, d2)
		return d1 .. value .. d2
	end)
end

local SPECIAL_FUNCS = {
	this_prop = function(prefab, element, property, ...)
		CheckArgCount("SpecFunc.this", 3, prefab, element, property, ...)
		return element[property]
	end,
	child_prop = function(prefab, element, child, property, ...)
		CheckArgCount("SpecFunc.child", 4, prefab, element, child, property, ...)
		return element:FindFirstChild(child)[property]
	end,
	this_attr = function(prefab, element, attrname, ...)
		CheckArgCount("SpecFunc.this_attr", 3, prefab, element, attrname, ...)
		return element:GetAttribute(attrname)
	end,
	child_attr = function(prefab, element, child, attrname, ...)
		CheckArgCount("SpecFunc.child_attr", 4, prefab, element, child, attrname, ...)
		return element:FindFirstChild(child):GetAttribute(attrname)
	end,
	str_varsub = function(prefab, element, str, ...)
		CheckArgCount("SpecFunc.str_id_sub", 3, prefab, element, str, ...)
		local temp = ` {str} `
		temp = strKeySub(temp, "pid", GetId(PREFAB_IDS, prefab))
		temp = strKeySub(temp, "eid", GetId(ELEMENT_IDS, element))
		temp = strKeySub(temp, "pname", prefab.Name)
		temp = strKeySub(temp, "ename", element.Name)
		temp = strKeySub(temp, "rand", math.random(0, 9999))
		temp = temp:gsub("{{", "{"):gsub("}}", "}"):sub(2, -2)
		return temp
	end,
}

function prefabSystem.OnAPILoaded(api: APIReference, prefabSystemState)
	hookName = api.GetRegistrantFactory("Sprix", "PrefabSystem")
	prefabSystemState.ExportCallbackToken = api.AddHook("PreSerialize", hookName("PreSerialize"), prefabSystem.OnSerializerExport)
end

function prefabSystem.OnAPIUnloaded(api: APIReference, prefabSystemState)
	if prefabSystemState.ExportCallbackToken then
		-- The unload function passed to DoAPILoop is called
		-- both when the API unloads, and when this plugin unloads
		-- as a result, removing any hooks in the unload function is no longer
		-- a "formality", but rather required
		api.RemoveHook(prefabSystemState.ExportCallbackToken)
	end
end

function prefabSystem.OnSerializerExport(hookState: {any}, invokeState: nil, mission: Folder)
	local warn = warnLogger.new("OnSerializerExport")
	local prefabFolder = mission:FindFirstChild("Prefabs")
	if not prefabFolder then return end
	
	local prefabInstanceFolder = mission:FindFirstChild("PrefabInstances")
	if not prefabInstanceFolder then
		-- Prevents prefabs from being exported & wasting space in the mission code
		prefabFolder:Destroy()
		return
	end
	
	local staticStates = {}
	for _, prefabInstance in ipairs(prefabInstanceFolder:GetDescendants()) do
		local warn = warn.specialize(`PrefabInstance {prefabInstance.Name} is invalid`)
		
		if prefabInstance:IsA("Folder") then continue end
		if prefabInstance.Parent:IsA("BasePart") then continue end
		
		if not prefabInstance:IsA("BasePart") then
			warn(`Expected BasePart, got {prefabInstance.ClassName}. Skipping.`)
			continue
		end
		
		local prefabInstanceType = prefabInstance:GetAttribute("PrefabName")
		if type(prefabInstanceType) ~= "string" then
			warn(`PrefabName attribute is of wrong datatype or otherwise invalid. Skipping.`)
			continue
		end
		
		local instantiatingPrefab = prefabFolder:FindFirstChild(prefabInstanceType)
		if instantiatingPrefab == nil then
			warn(`PrefabName points to non-existing prefab {prefabInstanceType}. Skipping.`)
			continue
		end
		
		local prefabStatic = staticStates[instantiatingPrefab] or {}
		prefabSystem.InstantiatePrefab(mission, instantiatingPrefab, prefabInstance, prefabStatic)
		staticStates[instantiatingPrefab] = prefabStatic
	end
	
	for _, prefab in ipairs(prefabFolder:GetChildren()) do
		if not prefab:IsA("Folder") then
			warn(`Prefab {prefab.Name} is invalid`, `Expected Folder, got {prefab.ClassName}`, "Prefab Will Be Ignored")
			continue
		end

		local prefabStatic = staticStates[prefab] or {}
		prefabSystem.UnpackPrefab(mission, prefab, "Static", function(mission, prefabTargetGroup)
			prefabSystem.DeepAttributeEvaluator(
				prefab,
				prefabTargetGroup,
				prefabSystem.InterpolateValue,
				{ Instance = prefabStatic, Static = prefabStatic }
			)
		end)
		
		prefabSystem.UnpackPrefab(mission, prefab, "Programmable", function(mission, prefabTargetGroup)
			local i = 0
			local descendantsNotDone = 0	
			local generatedFolder = Instance.new("Folder")
			local evaluated = {}
			repeat
				descendantsNotDone = 0
				local evaluating = prefabTargetGroup:Clone()
				evaluated = prefabSystem.DeepAttributeEvaluator(
					prefab,
					evaluating,
					prefabSystem.InterpolateValue,
					{ Instance = prefabStatic, Static = prefabStatic },
					{ "ignore.ProgrammableDone" }
				)["ignore.ProgrammableDone"] or {}
				
				for _, descendant in ipairs(evaluating:GetDescendants()) do
					local descendantIsFolder = descendant:IsA("Folder")
					if descendantIsFolder then
						if not glut.tbl_any(descendant:GetDescendants(), function(_, d) return evaluated[d] == false end) then
							descendant:Destroy()
							continue
						end
						descendant.Parent = generatedFolder
						continue
					end
					
					if evaluated[descendant] == true then descendant:Destroy() continue end
					if evaluated[descendant] == false then
						descendantsNotDone = descendantsNotDone + 1
						continue
					end
					
					warn(
						`Programmable Instance {descendant} does not have mandatory ProgrammableDone property`,
						`Instance will be destroyed`
					)
					descendant:Destroy()
				end
				
				i = i + 1
			until i > 2000 or descendantsNotDone <= 0
			
			if i > 2000 and descendantsNotDone > 0 then
				warn("Programmable group evaluation for the following did not finish in 2000 iterations:")
				for inst, v in pairs(evaluated) do
					if v ~= false then continue end
					warn(`\t{inst}`)
				end
			end
			
			return { generatedFolder }
		end)
	end
	
	-- Prevent these from being exported and taking up mission space
	prefabFolder:Destroy()
	prefabInstanceFolder:Destroy()
end

function prefabSystem.UnpackPrefab(mission: Folder, prefab: Folder, scope: string, preUnpack)
	preUnpack = glut.default(preUnpack, function() end)
	for _, prefabTargetGroup in ipairs(prefab:GetChildren()) do
		if not prefabTargetGroup:IsA("Folder") then
			warn(`PrefabTargetGroup {prefabTargetGroup.Name} is invalid - expected Folder, got {prefabTargetGroup.ClassName}. Skipping.`)
			continue
		end
		
		if not prefabTargetGroup.Name:lower():find(`^{scope:lower()}`) then continue end
		local modifiedTargets = preUnpack(mission, prefabTargetGroup) or {prefabTargetGroup}
		for _, modifiedTarget in ipairs(modifiedTargets) do
			prefabSystem.UnpackPrefabTargets(mission, modifiedTarget)
		end
	end
end

function prefabSystem.UnpackPrefabTargets(mission: Folder, targetGroup: Folder)
	local warn = warnLogger.new("UnpackPrefabTarget", "Prefab Target Invalid")
	
	for _, prefabTarget in ipairs(targetGroup:GetChildren()) do
		if prefabTarget.Name == "InstanceBase" then continue end
		
		if not prefabTarget:IsA("Folder") then
			warn(`Expected Folder, got {prefabTarget.ClassName}`, "Target will be ignored")
			continue
		end

		local missionPrefabTarget = mission:FindFirstChild(prefabTarget.Name) 
		if missionPrefabTarget == nil then warn(`Destination {prefabTarget.Name} not present`, "Create it if needed") continue end
		for _, prefabTargetItem in ipairs(prefabTarget:GetChildren()) do
			local itemIsFolder = prefabTargetItem:IsA("Folder")
			local missionFolder = missionPrefabTarget:FindFirstChild(prefabTargetItem.Name)
			if itemIsFolder and missionFolder ~= nil then
				for _, child in ipairs(prefabTargetItem:GetChildren()) do
					child:Clone().Parent = missionFolder
				end
				continue
			end
			prefabTargetItem:Clone().Parent = missionPrefabTarget 
		end
	end
end

function prefabSystem.InstantiatePrefab(mission: Folder, prefab: Folder, prefabInstance: BasePart, staticState)
	local warn = warnLogger.new("InstantiatePrefab", `Prefab {prefab.Name}`)
	
	local instanceTargetGroup = prefab:FindFirstChild("Instance") or prefab:FindFirstChild("instance")
	if not instanceTargetGroup then
		warn("Prefab may not be instantiated!")
		return
	end
	
	local instanceData = instanceTargetGroup:Clone()
	local instanceBase = instanceData:FindFirstChild("InstanceBase")
	if not instanceBase then
		warn("Instance folder found but no InstanceBase part present!")
		return
	end
	
	if not instanceBase:IsA("Part") then
		warn("InstanceBase found but not a part!")
		return
	end
	
	local sFuncStructure = prefabSystem.CollectSpecFuncAttrs(prefab, instanceBase, SPECIAL_FUNCS)
	prefabSystem.EvaluateSpecFuncs(prefab, prefabInstance, SPECIAL_FUNCS, sFuncStructure)
	
	local instanceSettings = instanceBase:GetAttributes()
	for settingName, instanceValue in pairs(prefabInstance:GetAttributes()) do
		local warn = warn.specialize(`Ignoring invalid attribute {settingName}`)
		
		if settingName == "PrefabName" then continue end
		
		local defaultValue = instanceSettings[settingName] 
		
		if type(defaultValue) == "string" then
			local isSFunc = prefabSystem.StrIsSpecFunc(defaultValue)
			if isSFunc then instanceSettings[settingName] = instanceValue continue end
		end
		
		if defaultValue == nil then
			warn("Attribute not present on InstanceBase")
			continue
		end
		
		if type(defaultValue) ~= type(instanceValue) then
			warn(`Expected type {type(defaultValue)} but got {type(instanceValue)}`)
			continue
		end
		
		instanceSettings[settingName] = instanceValue
	end
	
	local cfrSet = prefabSystem.DeepAttributeEvaluator(
		prefab,
		instanceData,
		prefabSystem.InterpolateValue, 
		{ Instance = instanceSettings, Static = staticState },
		{ "this.CFrame" }
	)["this.CFrame"] or {}
	
	for _, prefabElement in pairs(instanceData:GetDescendants()) do
		if prefabElement == instanceBase then continue end
		if not prefabElement:IsA("BasePart") then continue end
		if cfrSet[prefabElement] ~= nil then continue end
		local baseToElement = instanceBase.CFrame:ToObjectSpace(prefabElement.CFrame)
		prefabElement.CFrame = prefabInstance.CFrame:ToWorldSpace(baseToElement)
	end
	
	prefabSystem.UnpackPrefabTargets(mission, instanceData)
end

function prefabSystem.GetSortedAttributeList(instance)
	local instanceAttrs = instance:GetAttributes()
	local instanceAttrNames = {}
	for k, _ in pairs(instanceAttrs) do table.insert(instanceAttrNames, k) end
	
	table.sort(instanceAttrNames, function(a, b)
		local aIsHighP = string.match(a, "^highp%.") ~= nil
		local bIsHighP = string.match(b, "^highp%.") ~= nil
		local aIsLowP = string.match(a, "^lowp%.") ~= nil
		local bIsLowP = string.match(b, "^lowp%.") ~= nil
		
		local aNumericP = string.match(a, "^(%d+)%.")
		local bNumericP = string.match(b, "^(%d+)%.")
		local aIsNumericP = aNumericP ~= nil
		local bIsNumericP = bNumericP ~= nil
		
		if aIsNumericP and bIsNumericP then
			return tonumber(aNumericP) < tonumber(bNumericP)
		elseif aIsNumericP then
			return true
		elseif bIsNumericP then
			return false
		end
		
		if aIsHighP and not bIsHighP then
			return true
		elseif bIsHighP and not aIsHighP then
			return false
		elseif aIsLowP and not bIsLowP then
			return false
		elseif bIsLowP and not aIsLowP then
			return true
		else
			return a < b
		end
	end)
	
	return instanceAttrNames
end

function prefabSystem.IsProgrammable(inst)
	for n, _ in pairs(inst:GetAttributes()) do
		if glut.str_has_match(n, "ProgrammableDone$") then return true end
	end
	return false
end

function prefabSystem.DeepAttributeEvaluator(prefab: Folder, root: Instance, evaluator, evalData, attrCapture, programmableRecurse)
	attrCapture = glut.default(attrCapture, {})
	programmableRecurse = glut.default(programmableRecurse, false)
	local warn = warnLogger.new("Attribute Evaluation", `{root.Parent}.{root}`)
	
	if prefabSystem.IsProgrammable(root) and not programmableRecurse then
		local evalLimit = root:GetAttribute("ignore.ProgrammableEvalLimit")
		if type(evalLimit) ~= "number" then evalLimit = 2000 end
		
		local attrCapture = glut.tbl_clone(attrCapture)
		local allCaptured = {}
		if not table.find(attrCapture, "ignore.ProgrammableDone") then table.insert(attrCapture, "ignore.ProgrammableDone") end
		local i = 0
		repeat
			i = i + 1
			local rootClone = root:Clone()
			rootClone.Parent = root.Parent
			local setQuery = prefabSystem.DeepAttributeEvaluator(
				prefab,
				rootClone,
				evaluator,
				evalData,
				attrCapture,
				true
			)
			local doneSet = setQuery["ignore.ProgrammableDone"][rootClone]
			if doneSet then rootClone:Destroy() end
			allCaptured = glut.tbl_merge(allCaptured, setQuery)
		until doneSet or i >= evalLimit
		if i >= evalLimit then
			warn(
				`Error evaluating programmable instance - did not finish after {evalLimit} evaluations`,
				"If intentional - this limit may be altered by setting \"ignore.ProgrammableEvalLimit\" to a number of your choosing"
			)
		end
		root:Destroy()
		return allCaptured
	end
	
	local setQuery = {}
	for _, attrName in ipairs(prefabSystem.GetSortedAttributeList(root)) do
		local attrValue = root:GetAttribute(attrName)
		if type(attrValue) ~= "string" then continue end
		local success, interpolatedAttrValue = evaluator(prefab, root, attrName, attrValue, evalData)
		if not success then
			warn(interpolatedAttrValue, "Attribute will be ignored")
			root:SetAttribute(attrName, nil)
			continue
		end
		
		local pName = attrName:match("^highp%.(.+)$") or attrName:match("^lowp%.(.+)$") or attrName:match("^%d+%.(.+)$")
		if pName ~= nil then
			root:SetAttribute(attrName, nil)
			attrName = pName
		end
		
		for _, querying in ipairs(attrCapture) do
			if attrName == querying then
				setQuery[querying] = setQuery[querying] or {}
				setQuery[querying][root] = interpolatedAttrValue
			end
		end
		
		local ignoreName = attrName:match("^ignore%.([_%w]+)$")
		if ignoreName ~= nil then
			root:SetAttribute(attrName, nil)
			continue
		end
		
		local propName = attrName:match("^this%.([_%w]+)$")
		if propName ~= nil then
			local success, reason = pcall(function()
				if typeof(root[propName]) == "EnumItem" then
					interpolatedAttrValue = root[propName].EnumType:FromName(interpolatedAttrValue)
				end
				root[propName] = interpolatedAttrValue
			end)
			if not success then
				warn(`Failed to set Property {propName}`, reason) 
			end
			root:SetAttribute(attrName, nil)
			continue
		end
		
		root:SetAttribute(attrName, interpolatedAttrValue)
	end
	
	local success, interpolatedName = evaluator(prefab, root, `{root}.Name`, root.Name, evalData)
	if success and type(interpolatedName) == "string" then
		root.Name = interpolatedName
	elseif success then
		warn("Name evaluation resolved to a non-string value")
	end
	
	for _, child in ipairs(root:GetChildren()) do
		local childSet = prefabSystem.DeepAttributeEvaluator(prefab, child, evaluator, evalData, attrCapture, programmableRecurse)
		for attrName, hit in pairs(childSet) do
			setQuery[attrName] = setQuery[attrName] or {}
			local subTbl = setQuery[attrName]
			for inst, val in pairs(hit) do
				subTbl[inst] = val
			end
		end
	end
	
	return setQuery
end

function prefabSystem.CreateShebangFenv(inst, state, staticState)
	local tableLib = glut.tbl_clone(table)
	local stringLib = glut.tbl_clone(string)
	
	stringLib.split = glut.str_split
	tableLib.getkeys = glut.tbl_getkeys
	
	local fenvBase = {
		state = state,
		static = staticState,
		staticState = staticState,
		math = math,
		table = tableLib,
		string = stringLib,
		CFrame = CFrame,
		Color3 = Color3,
		Vector2 = Vector2,
		Vector3 = Vector3,
		tostring = tostring,
		tonumber = tonumber,
		pairs = pairs,
		ipairs = ipairs,
		next = next,
		print = print,
		setAttributes = function(t) for k, v in pairs(t) do inst:SetAttribute(k, v) end return true end
	}
	
	-- state can't overshadow builtin libraries
	setmetatable(fenvBase, { __index = state })
	return fenvBase
end

function prefabSystem.InterpolateValue(prefab: Folder, element: Instance, name: string, value: string, state: { [string] : any }) : any
	local exprName = `{element.Parent}.{element}:{name}`
	local warn = warnLogger.new("Attribute Interpolation", exprName)
	
	local instState = state.Instance
	local staticState = state.Static
	
	local shebangContents = string.match(value, "^#!/lua%s+(.*)$")
	if shebangContents ~= nil then
		local warn = warn.specialize("ShebangScriptExec")
		local success, count, args = glut.str_runlua(
			shebangContents,
			prefabSystem.CreateShebangFenv(element, instState, staticState),
			exprName
		)
		
		if not success then
			return success, count
		end
		
		if count > 1 then
			warn(`Script execution succeeded, but {count-1} extra values were returned`, "Extra values will be ignored")
		elseif count == 0 then
			warn("Script execution succeeded, but no value was returned", "Attribute will be ignored")
			return false, nil
		end
		return success, args[1]
	end
	
	local success, evalResult = luaExpr.Eval(
		value,
		luaExprFuncs.CreateExprFenv(element, instState, staticState),
		exprRules,
		exprName,
		false
	)
	
	if not success then
		if type(evalResult) == "string" then
			warn(evalResult)
		end
		evalResult = nil
	end

	return success, evalResult
end

function prefabSystem.CollectSpecFuncAttrs(prefab, root, sfuncs)
	local selfTbl = { Attributes = {}, Children = {} }
	
	for attrName, attrVal in pairs(root:GetAttributes()) do
		if type(attrVal) ~= "string" then continue end
		local success, sfuncData = prefabSystem.ParseSpecFunc(prefab, root, attrVal, sfuncs)
		if not success then continue end
		
		selfTbl.Attributes[attrName] = sfuncData
	end
	
	for _, baseElem in ipairs(root:GetChildren()) do
		selfTbl.Children[baseElem.Name] = prefabSystem.CollectSpecFuncAttrs(prefab, baseElem, sfuncs)
	end
	
	return selfTbl
end

function prefabSystem.EvaluateSpecFuncs(prefab, root, sfuncs, data)
	local warn = warnLogger.new("EvaluateSpecFuncs")
	
	for childName, childData in pairs(data.Children) do
		local childInstance = root:FindFirstChild(childName)
		if childInstance == nil then warn(`Expected instance {root.Name}.{childName} not found`) continue end
		prefabSystem.EvaluateSpecFuncs(prefab, childInstance, sfuncs, childData)
	end

	for attrName, sFuncData in pairs(data.Attributes) do
		if root:GetAttribute(attrName) ~= nil then continue end
		local success, result = prefabSystem.EvaluateSpecFunc(prefab, root, sFuncData)
		if not success then continue end
		root:SetAttribute(attrName, result)
	end
end

local SPECFUNCS_SUBSTITUTION_PATTERN = "%${(.+)}"
function prefabSystem.StrIsSpecFunc(str)
	local sfuncContent = string.match(str, `^{SPECFUNCS_SUBSTITUTION_PATTERN}$`)
	return sfuncContent ~= nil, sfuncContent
end

function prefabSystem.ParseSpecFunc(prefab, element, sfuncStr, sfuncs)
	local warn = warnLogger.new("SFuncParsing", `{element.Parent.Name}.{element.Name}`, sfuncStr)
	
	local isSfunc, sfuncContent = prefabSystem.StrIsSpecFunc(sfuncStr)
	if not isSfunc then return false, nil end

	local sfuncArgs = {}
	local sfuncCurrentArg = ""
	local escaping = false
	local inStr = false
	for c in string.gmatch(sfuncContent, ".") do
		if c:match("^%s$") and not inStr then continue end
		if c == "\\" and not escaping then escaping = true continue end
		if c == "\"" and not escaping and not inStr then inStr = true continue end
		if c == "\"" and not escaping and inStr then inStr = false continue end

		if c == "," and not escaping and not inStr then
			table.insert(sfuncArgs, sfuncCurrentArg)
			sfuncCurrentArg = ""
			continue
		end

		if c == 'n' and escaping then
			sfuncCurrentArg = sfuncCurrentArg .. "\n"
		elseif c == 't' and escaping then
			sfuncCurrentArg = sfuncCurrentArg .. "\t"
		elseif escaping then
			warn(`Received unknown escape \"\\{c}\", ignoring backslash and treating as a normal character`)
			sfuncCurrentArg = sfuncCurrentArg .. c
		else
			sfuncCurrentArg = sfuncCurrentArg .. c
		end

		escaping = false
	end
	table.insert(sfuncArgs, sfuncCurrentArg)

	local sfuncExpectedType = table.remove(sfuncArgs, 1)
	local sfuncName = table.remove(sfuncArgs, 1)
	local sfunc = sfuncs[sfuncName]
	if sfunc == nil then
		warn(`SpecialFunc \"{sfuncName}\" not found!`)
		return false, nil
	end
	
	return true, {
		Func = sfunc,
		Name = sfuncName,
		Args = sfuncArgs,
		Type = sfuncExpectedType,
		Expr = sfuncContent
	}
end

function prefabSystem.EvaluateSpecFunc(prefab, element, sfuncData)
	local warn = warnLogger.new("SFuncExec", sfuncData.Expr, sfuncData.Name)
	
	local success, result = pcall(sfuncData.Func, prefab, element, unpack(sfuncData.Args))
	if success and typeof(result) == sfuncData.Type then return success, result end
	if not success then
		warn(`Execution failed with reason \"{result}\"`)
		return success, result
	end
	
	warn(`Executed successfully but did not return expected type {sfuncData.Type}`)
	return false, nil
end

apiConsumer.DoAPILoop(plugin, API_ID, prefabSystem.OnAPILoaded, prefabSystem.OnAPIUnloaded)]]></ProtectedString>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{2EFB673D-CAA3-471F-972B-512807FDA430}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Main</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX641E75C74AAF4698AE7A4788DD682E84">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[--[[
	This module is provided for convenience of consumers of the serializer API
	providing a reference implementation for correctly retrieving and validating a reference to the API table

	For a working example of a plugin making use of this API via this module
	see: https://github.com/Sprixitite/InfiltrationEngine-PrefabSystem
]]

local coreGui = game:GetService("CoreGui")

export type Token = string
export type Hook = (...any) -> nil
export type HookType = "APIExtensionLoaded"|"APIExtensionUnloaded"|"PreSerialize"|"PreSerializeMissionSetup"|"SerializerUnloaded"
export type APIExtension = { [string] : (...any) -> ...any }

export type APIReference = {
	-- Generic
	GetAPIVersion 			: () -> number,
	GetCodeVersion 			: () -> number,
	GetAttributesMap 		: () -> { [string] : { [number] : any } },
	GetAttributeTypes 		: () -> { [string] : number },
	GetRegistrantFactory	: (author: string, plugin: string) -> ((hookName: string) -> string), 

	-- HookTypes
	GetHookTypes 			: () -> { [number] : string },
	IsHookTypeValid 		: (hookType: string, warnCaller: string?) -> boolean,

	-- Hooks
	AddHook 				: (hookType: HookType, registrant: string, hook: Hook, hookState: {any}?) -> Token,
	RemoveHook 				: (token: Token) -> nil,

	-- APIExtensions
	AddAPIExtension 		: (name: string, author: string, contents: APIExtension) -> Token,
	GetAPIExtension			: (name: string, author: string) -> APIExtension,
	RemoveAPIExtension		: (token: Token) -> nil
}

type AnyTbl = { [string] : any }

local APIConsumer = {}

local function ValidateArgTypes(fname: string, ...) : boolean
	local args = {...}
	for _, argSettings in ipairs(args) do
		local argName = argSettings[1]
		local argValue = argSettings[2]
		local argType = type(argValue)
		local argExpectedType = argSettings[3]
		if argType ~= argExpectedType then
			warn(`Invalid argument {argName} passed to function {fname} - expected type {argExpectedType} but got {argType}!`)
			return false
		end
	end
	return true
end

APIConsumer.ValidateArgTypes = ValidateArgTypes

-- Yields until timeOut is elapsed or API is found
APIConsumer.WaitForAPI = function(timeOut: number?) : APIReference?
	timeOut = if timeOut == nil then math.huge else timeOut

	if not ValidateArgTypes(
		"WaitForAPI",
		{"timeOut", timeOut, "number"}
		) then return end

	local presenceIndicator = coreGui:WaitForChild("InfilEngine_SerializerAPIAvailable", timeOut)
	if not presenceIndicator then return end

	local apiTbl = shared.InfilEngine_SerializerAPI
	if not (tostring(apiTbl) == presenceIndicator.Value) then return end

	return apiTbl
end

-- Attempt to get the API without blocking - returns false + nil if unavailable, otherwise returns true + APIReference
APIConsumer.TryGetAPI = function() : (boolean, APIReference?)
	local presenceIndicator = coreGui:FindFirstChild("InfilEngine_SerializerAPIAvailable")
	if not presenceIndicator then return false, nil end

	local apiTbl = shared.InfilEngine_SerializerAPI
	if not (tostring(apiTbl) == presenceIndicator.Value) then return false, nil end

	return true, apiTbl
end

-- Never returns unless there's an error
-- Continually wires up handling of serializer load/unload as well as unloading of consumer plugin as needed
-- Avoid doing this yourself if you can help it
APIConsumer.DoAPILoop = function<StateT>(
	callerPlugin: Plugin,
	srcname: string,
	loadedClbck: (api: APIReference, state: StateT) -> nil,
	unloadedClbck: (api: APIReference, state: StateT) -> nil, 
	state: StateT?
) : never
	state = if state == nil then {} else state

	if typeof(callerPlugin) ~= "Instance" then
		warn(`Invalid argument callerPlugin passed to DoAPILoop - expected type Plugin but got {typeof(callerPlugin)}!`)
		return
	end

	if callerPlugin.ClassName ~= "Plugin" then
		warn(`Invalid argument callerPlugin passed to DoAPILoop - expected type Plugin but got {callerPlugin.ClassName}!`)
		return
	end

	if not ValidateArgTypes(
		"DoAPILoop", 
		{"srcname", srcname, "string"},
		{"loadedClbck", loadedClbck, "function"},
		{"unloadedClbck", unloadedClbck, "function"},
		{"state", state, "table"}
		) then return end

	local api = APIConsumer.WaitForAPI()
	if api == nil then return APIConsumer.DoAPILoop(callerPlugin, srcname, loadedClbck, unloadedClbck, state) end

	loadedClbck(api, state)

	local pluginUnloadCallback
	local unloadToken

	pluginUnloadCallback = callerPlugin.Unloading:Connect(function()
		pluginUnloadCallback:Disconnect()
		pluginUnloadCallback = nil
		unloadedClbck(api, state)
		if unloadToken ~= nil then api.RemoveHook(unloadToken) end
	end)

	unloadToken = api.AddHook("SerializerUnloaded", `APIConsumerFramework_{srcname}`, function()
		if pluginUnloadCallback then pluginUnloadCallback:Disconnect() pluginUnloadCallback = nil end
		unloadedClbck(api, state)
		task.spawn(APIConsumer.DoAPILoop, callerPlugin, srcname, loadedClbck, unloadedClbck, state)
	end)
end

return APIConsumer]]></ProtectedString>
				<string name="ScriptGuid">{9C413FEA-27C9-4E1A-A9CC-E7239C0F162A}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">APIConsumer</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX1DBB279406E4468EAD60FBBC2983C462">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[--[[
	Slogger, yet another minimal Lua logging module
	Log function + post-init function are configurable, for dealing with the slog that is lua version compatibility
	
	Tested to be compatible with Lua5.1
	Presumed compatible with Lua5.2-5.5/Luajit/Luau
	
	© Sprixitite, 2025
]]

local slogger = {}

local sloggerCfg = {
	postInit = function(tbl) return tbl end,
	logFunc = print
}

local function varargs(...)
	local argCount = select('#', ...)
	local argTbl = { ... }
	local i = 0
	return function()
		i = i + 1
		if i <= argCount then return i, argTbl[i], argCount end
	end, argTbl
end

function slogger.new(...)
	local loggerPrefix = ""
	local varargsIter, argsTbl = varargs(...)
	
	for i, arg in varargsIter do
		loggerPrefix = loggerPrefix .. tostring(arg) .. " : "
	end
	
	local doWarn = function(tbl, ...)
		local finalMsg = ""
		
		for i, arg, argCount in varargs(...) do
			finalMsg = finalMsg .. tostring(arg)
			if i ~= argCount then
				finalMsg = finalMsg .. " : "
			end
		end
		
		sloggerCfg.logFunc(loggerPrefix .. finalMsg)
	end
	
	local specialize = function(...)
		return slogger.new(unpack(argsTbl), ...)
	end
	
	local newLogger = setmetatable({ specialize = specialize }, {__call = doWarn})
	return sloggerCfg.postInit(newLogger)
end

function slogger.init(cfg)
	for k, v in pairs(cfg) do
		if type(sloggerCfg[k]) == type(v) then
			sloggerCfg[k] = v
		end
	end
	return slogger
end

return slogger]]></ProtectedString>
				<string name="ScriptGuid">{9A026DAB-AF18-4CD8-98AE-F24BAF01A1ED}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Slogger</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXBAF4960F1083438FBA65261083C7BFA7">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[local glut = require("./GLUt")

local LuaExpr = {}

local LUA_EXPR_BODY_STRMATCH = "([\\\'\"%-%+%*%^%.,:/_%w%s{}<>!=+|#]+)"

function LuaExpr.MakeEvalRules(prefix, delim)
	local bodyMatch = prefix .. LUA_EXPR_BODY_STRMATCH .. delim 
	return {
		BodyMatch = bodyMatch,
		SoleMatch = '^' .. bodyMatch .. '$'
	}
end

local LUA_EXPR_MATCH_DEFAULT = LuaExpr.MakeEvalRules("%$%(", "%)")

function LuaExpr.IsSoleExpr(str, rules)
	local soleExprData = string.match(str, rules.SoleMatch)
	return soleExprData ~= nil, soleExprData
end

function LuaExpr.EvalSoleExpr(str, fenv, rules, exprName, multiRet)
	exprName = glut.default_typed(exprName, "LUAEXPR_UNNAMED", "exprName", "LuaExpr.EvalSoleExpr")
	multiRet = glut.default_typed(multiRet, false, "multiRet", "LuaExpr.EvalSoleExpr")
	
	local leadingReturn = string.match(str, "^return%s+")
	if leadingReturn == nil then str = "return " .. str end
	
	local success, count, args = glut.str_runlua(str, fenv, exprName)
	if not success then
		return false, "LuaExpr : " .. exprName .. " : Evaluation failed : " .. count
	end
	
	return success, args[1]
end

function LuaExpr.Eval(str, fenv, rules, exprName, soleOnly)
	if not glut.type_check(str, "string", "str", "LuaExpr.Eval") then return end
	if not glut.type_check(fenv, "table", "fenv", "LuaExpr.Eval") then return end
	
	rules = glut.default_typed(rules, LUA_EXPR_MATCH_DEFAULT, "rules", "LuaExpr.Eval")
	exprName = glut.default_typed(exprName, "LUAEXPR_UNNAMED", "epxrName", "LuaExpr.Eval")
	soleOnly = glut.default_typed(soleOnly, false, "soleOnly", "LuaExpr.Eval")
	
	local isSole, soleData = LuaExpr.IsSoleExpr(str, rules)
	if isSole then return LuaExpr.EvalSoleExpr(soleData, fenv, rules, exprName, isSole) end
	if soleOnly then return false, nil end
	
	local i = 0
	return true, string.gsub(str, rules.BodyMatch, function(subexpr)
		i = i+1
		local subExprName = exprName .. '#' .. tostring(i)
		local evalSuccess, evalVal = LuaExpr.EvalSoleExpr(subexpr, fenv, rules, subExprName, false)
		return tostring(evalVal)
	end)
end

return LuaExpr]]></ProtectedString>
				<string name="ScriptGuid">{DE119178-750B-474C-BF0B-A605B90864FB}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">LuaExpr</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX94E910B35AC949789C94D94D0EAD462C">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[--[[
	GLUt // GoodLuaUtilities // Lua5.1 utilities module
	
	© Sprixitite, 2025
]]

local GLUt = {}

local GLUtCfg = {
	print = print,
	warn  = function(...) print("WARNING", ...) end,
	error = error,
	type  = type
}

local patternSpecChars = { '(', ')', '.', '%', '+', '-', '*', '?', '[', ']', '^', '$' }

function GLUt.configure(tbl)
	for k, v in pairs(tbl) do
		if GLUtCfg[k] ~= nil then
			GLUtCfg[k] = v
		else
			GLUtCfg.warn("Attempt to set invalid GLUtCfg Key \"" .. tostring(k) .. "\"")
		end
	end
end

function GLUt.default(arg, default)
	return (arg == nil) and default or arg
end

function GLUt.default_exec(arg, fn)
	return (arg == nil) and fn() or arg
end

function GLUt.default_typed(arg, default, argName, funcName)
	local argType = GLUtCfg.type(arg)
	local defaultType = GLUtCfg.type(default)
	if argType == defaultType then return arg end
	if argType == "nil" then return default end
	GLUt.type_warn(argName, funcName, defaultType, argType)
	return default
end

function GLUt.type_warn(argName, funcName, expected, got, isErr)
	if argName == nil or expected == got then return end
	isErr = GLUt.default(isErr, false)
	
	local logFun = isErr and GLUtCfg.error or GLUtCfg.warn

	local warnStart = GLUt.type_is(funcName, "string") and (funcName .. ": expected arg \"") or "Expected arg \""
	logFun(warnStart .. argName .. "\" of type \"" .. expected .. "\" got type \"" .. got .. "\"!")
	logFun("Traceback: " .. debug.traceback())
end

function GLUt.type_check(arg, expected, argName, funcName, isErr)
	isErr = GLUt.default(isErr, false)
	local argType = GLUtCfg.type(arg)

	expected = string.gsub(expected, '?', "|nil")
	for _, validType in pairs(GLUt.str_split(expected, '|')) do
		if validType == argType then return true end
	end

	GLUt.type_warn(argName, funcName, expected, argType, isErr)

	return false
end

function GLUt.type_is(a1, t)
	return GLUtCfg.type(a1) == t
end

function GLUt.type_eq(a1, a2)
	return GLUtCfg.type(a1) == GLUtCfg.type(a2)
end

function GLUt.vararg_capture(...)
	local n = select('#', ...)
	return n, { ... }
end

function GLUt.vararg_iter(...)
	local n, t = GLUt.vararg_capture(...)
	local i = 0
	return function()
		i = i + 1
		if i <= n then return i, t[i], n end
	end, t
end

function GLUt.str_split(str, separator)
	str = str .. separator
	separator = GLUt.str_escape_pattern(separator)

	local substrs = {}
	for substr in string.gmatch(str, "(.-)" .. separator) do
		substrs[#substrs+1] = substr
	end
	return substrs
end

function GLUt.str_has_match(str, pattern)
	return string.match(str, pattern) ~= nil
end

function GLUt.str_escape_pattern(str)
	local escaped = str
	for _, specChar in ipairs(patternSpecChars) do
		local escapedSpec = '%' .. specChar
		escaped = string.gsub(escaped, escapedSpec, (specChar == '%') and "%%" or '%' .. escapedSpec)
	end
	return escaped
end

function GLUt.str_double_substr(str, substr)
	local safe = GLUt.str_escape_pattern(substr)
	return string.gsub(str, safe, safe .. safe)
end

function GLUt.str_isempty(str)
	return string.match(str, "^%s$") ~= nil
end

function GLUt.str_chariter(str)
	local n = #str
	local i = 0
	return function()
		i = i + 1
		if i <= n then return GLUt.str_getchar(str, i) end
	end
end

function GLUt.str_getchar(str, i)
	return string.sub(str, i, i)
end

local unidentified = -1
function GLUt.str_runlua(source, fenv, chunkName)
	chunkName = GLUt.default_exec(chunkName, function()
		unidentified = unidentified + 1
		return "loadstring#" .. tostring(unidentified) 
	end)

	local strFun, failReason = loadstring(source, chunkName)
	if GLUtCfg.type(strFun) ~= "function" then
		return false, "Loadstring : " .. chunkName .. " : Evaluation failed : " .. failReason
	end

	strFun = setfenv(strFun, fenv)

	return pcall(function()
		return GLUt.vararg_capture(strFun())
	end)
end

function GLUt.str_runlua_unsafe(source, chunkName)
	local strFun, failReason = loadstring(source, chunkName)
	if GLUtCfg.type(strFun) ~= "function" then
		return false, "Loadstring : " .. chunkName .. " : Evaluation failed : " .. failReason
	end

	return pcall(function()
		return GLUt.vararg_capture()
	end)
end

function GLUt.kvp_tostring(k, v)
	return tostring(k) .. " = " .. tostring(v)
end

function GLUt.tbl_tryindex(tbl, ...)
	local indexing = tbl
	for _, k in GLUt.vararg_iter(...) do
		if GLUtCfg.type(indexing) ~= "table" then
			return false, indexing
		end
		indexing = indexing[tostring(k)]
	end

	return true, indexing
end

function GLUt.tbl_deepget(tbl, create_missing, ...)
	local indexing = tbl
	for _, k in GLUt.vararg_iter(...) do
		k = tostring(k)
		if GLUtCfg.type(indexing) ~= "table" then
			return false, indexing
		end
		
		if indexing[k] == nil and create_missing then
			indexing[k] = {}
		end
		
		indexing = indexing[k]
	end
	
	return true, indexing
end

function GLUt.tbl_getkeys(tbl)
	local keys = {}
	for k, _ in pairs(tbl) do keys[#keys+1] = k end
	return keys
end

function GLUt.tbl_clone(tbl, shallow)
	shallow = GLUt.default(shallow, false)

	local cloned = {}
	for k, v in pairs(tbl) do
		if GLUtCfg.type(v) == "table" and not shallow then
			cloned[k] = GLUt.tbl_clone(v, shallow)
		else
			cloned[k] = v
		end
	end
	return cloned
end

function GLUt.tbl_merge(tbl1, tbl2, priority)
	priority = GLUt.default(priority, 1)
	local secondPriority = priority == 2
	local merged = {}
	for k, v in pairs(tbl1) do
		merged[k] = v
	end
	for k, v in pairs(tbl2) do
		local existing = merged[k]
		if GLUtCfg.type(existing) == "table" then
			merged[k] = GLUt.tbl_merge(existing, v, priority)
		elseif existing ~= nil and secondPriority then
			merged[k] = v
		elseif merged[k] == nil then
			merged[k] = v
		end
	end
	return merged
end

function GLUt.tbl_findsize(tbl)
	local i = 0
	for _, _ in pairs(tbl) do i = i + 1 end
	return i
end

local function tbl_tostring(tblName, tbl, levels, level)
	local str = tblName .. " = {"
	local indent = string.rep("  ", level)
	local n = GLUt.tbl_findsize(tbl)
	local i = 0
	for k, v in pairs(tbl) do
		i = i + 1
		str = str .. '\n' .. indent
		if GLUtCfg.type(v) == "table" and levels > level then
			str = str .. tbl_tostring(k, v, levels, level+1)
		else
			str = str .. GLUt.kvp_tostring(k, v)
		end
		if i < n then str = str .. ',' end
	end
	return str
end

function GLUt.tbl_tostring(tbl, levels, tblName)
	GLUt.default(tblName, tostring(tbl))
	return tbl_tostring(tblName, tbl, levels, 1)
end

function GLUt.tbl_any(tbl, f)
	local anySucceed = nil
	for k, v in pairs(tbl) do
		anySucceed = GLUt.default(anySucceed, false) or f(k, v)
		if anySucceed then break end
	end
	return anySucceed
end

function GLUt.tbl_all(tbl, f)
	local allSucceed = nil
	for k, v in pairs(tbl) do
		allSucceed = GLUt.default(allSucceed, true) and f(k, v)
		if not allSucceed then break end
	end
	return allSucceed
end

local function tbl_arginfo(argType, name, index, expectedType)
	local typeStr = GLUt.type_is(expectedType, "string") and (" <T:" .. expectedType .. ">") or ""
	return argType .. " \"" .. name .. "\" (#" .. tostring(index) .. ")" .. typeStr 
end

local function tbl_argextract(fname, t, arglayout)
	local index = arglayout[1]
	local name = arglayout[2]
	local expectedType = arglayout[3]
	local canName = arglayout[4]
	local default = arglayout.Default or arglayout.default
	local vital = GLUt.default(arglayout.Vital or arglayout.vital, false)
	
	local tVal = t[index]
	if canName and tVal ~= nil then
		if t[name] ~= nil then
			return GLUtCfg.error(fname .. "@tblcall : " .. tbl_arginfo("Arg", name, index, expectedType) .. " passed both by name and index!")
		end
	elseif canName then
		tVal = t[name]
	end
	
	if tVal == nil and default ~= nil then
		tVal = default
	end
	
	if tVal == nil and expectedType == false then
		return nil
	elseif tVal == nil then
		local argType = vital and "Vital Arg" or "Arg"
		return GLUtCfg.error(fname .. "@tblcall : " .. tbl_arginfo(argType, name, index, expectedType) .. " not passed!")
	end
	
	if expectedType == false then return tVal end
	if not GLUt.type_check(tVal, expectedType, name, fname, true) then return nil end
	return tVal
end

function GLUt.fun_tblcallable(fname, f, ...)
	local n, callingConvention = GLUt.vararg_capture(...)
	return function(tbl)
		for k, v in pairs(tbl) do
			local isValid = false
			for i=1, n do
				if isValid then break end
				local validArg = callingConvention[i]
				isValid = (k == i) or (k == validArg[2])
			end
			if not isValid then
				GLUtCfg.error("Received unexpected argument \"" .. tostring(k) .. "\" of type \"" .. GLUtCfg.type(v) .. "\"!")
			end
		end
		local args = {}
		for i=1, n do
			local argLayout = callingConvention[i]
			args[i] = tbl_argextract(fname, tbl, argLayout)
		end
		return f(unpack(args, 1, n))
	end
end

return GLUt]]></ProtectedString>
				<string name="ScriptGuid">{7484DC6C-C136-46C9-992B-BD6809BF968D}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">GLUt</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXCD60A5F6378E4E8B87F68498500E2C3D">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[local glut = require("./GLUt")

local luaExprFuncs = {}

local function StaticGroupErr(groupName)
	error("Attempt to set StaticStateGroup " .. groupName .. " but encountered non-table element!")
end

local function returnArgs(...) return ... end

local function ExprFunc(fname, f, ...)
	local tblCallable = glut.fun_tblcallable(fname, returnArgs, ...)
	return function(inst, state, staticState, t)
		return f(inst, state, staticState, tblCallable(t))
	end
end

local function ExprFuncOverload(fname, f, foverloading, ...)
	local tblCallable = glut.fun_tblcallable(fname, returnArgs, ...)
	return function(inst, state, staticState, t)
		local overloaded = function() return foverloading(inst, state, staticState, t) end
		return f(inst, state, staticState, overloaded, tblCallable(t))
	end
end

luaExprFuncs.setAttributes = ExprFunc(
	"setAttributes",
	function(inst, state, staticState, attrs)
		for k, v in pairs(attrs) do
			inst:SetAttribute(k, v)
		end
		return true
	end,
	{ 1, "attributes", "table", false, vital=true }
)

luaExprFuncs.staticGroupExport = ExprFunc(
	"staticGroupExport",
	function(inst, state, staticState, groupName, exportValue, allowDuplicates)
		-- Exports a variable as a member of a staticState group, creating the group if it does not exist
		local groupPath = glut.str_split(groupName, '.')
		local success, groupTbl = glut.tbl_deepget(staticState, true, unpack(groupPath))
		if not success then StaticGroupErr(groupName) end
		if not allowDuplicates then
			if table.find(groupTbl, exportValue) then return exportValue end
		end
		table.insert(groupTbl, exportValue)
		return exportValue
	end,
	{ 1, "groupName", "string", false, vital=true },
	{ 2, "exportValue", false, false, vital=true },
	{ 3, "allowDuplicates", "boolean", true, default=false }
)

luaExprFuncs.staticGroupCombine = ExprFunc(
	"staticGroupCombine",
	function(
		inst, state, staticState,
		groupName,
		combineOp,
		prefix,
		suffix,
		field,
		itemPrefix,
		itemSuffix
	)
		-- Concatenates the string representation of all members of a staticState group, using the specified operator inbetween all elements
		local groupPath = glut.str_split(groupName, '.')
		local success, groupTbl = glut.tbl_deepget(staticState, false, unpack(groupPath))
		if not success then StaticGroupErr(groupName) end
		local str = prefix .. "("
		for i, v in ipairs(groupTbl) do
			if i ~= 1 then str = str .. combineOp end
			local vStr = (field == nil) and tostring(v) or tostring(v[field])
			str = str .. itemPrefix .. vStr .. itemSuffix
		end
		str = str .. ")" .. suffix
		return str
	end,
	{ 1, "groupName", "string", false, vital=true },
	{ 2, "combineOp", "string", false, vital=true },
	{ 3, "prefix", "string", true, default="" },
	{ 4, "suffix", "string", true, default="" },
	{ 5, "field", false, true, default=nil },
	{ 6, "itemPrefix", "string", true, default="" },
	{ 7, "itemSuffix", "string", true, default="" }
)

luaExprFuncs.staticGroupEmpty = ExprFunc(
	"staticGroupEmpty",
	function(inst, state, staticState, groupName)
		-- Returns true if the StaticStateGroup at the given path is empty
		return luaExprFuncs.staticGroupSize(inst, state, staticState, { groupName }) == 0
	end,
	{ 1, "groupName", "string", false, vital=true }
) 

luaExprFuncs.staticGroupSize = ExprFunc( 
	"staticGroupSize",
	function(inst, state, staticState, groupName, asString, quietFail)
		-- Returns the size of the StaticStateGroup at the given path - optionally as a string
		local groupPath = glut.str_split(groupName, '.')
		local success, groupTbl = glut.tbl_deepget(staticState, false, unpack(groupPath))
		if not success and not quietFail then
			StaticGroupErr(groupName)
		elseif not success then
			return 0
		end
		return (asString and tostring(#groupTbl)) or #groupTbl
	end,
	{ 1, "groupName", "string", false, vital=true },
	{ 2, "asString", "boolean", true, default=false },
	{ 3, "quietFail", "boolean", true, default=false }
)

luaExprFuncs.moveFirstStaticElement = ExprFunc(
	"moveFirstStaticElement",
	function(
		inst, state, staticState,
		groupName,
		destName,
		pairItem,
		quietFail
	)
		-- Removes the first element of the StaticStateGroup at the given path, and places it
		if pairItem ~= 'k' and pairItem ~= 'v' then error("pairItem must be nil|\"k\"|\"v\"!") end
		local groupPath = glut.str_split(groupName, '.')
		local destPath = glut.str_split(destName, '.')
		local destKey = table.remove(destPath, #destPath)
		local success, groupTbl = glut.tbl_deepget(staticState, false, unpack(groupPath))
		if not success then StaticGroupErr(groupName) end
		local success, destTbl = glut.tbl_deepget(staticState, true, unpack(destPath))
		if not success then StaticGroupErr(destName) end
		local groupKeys = glut.tbl_getkeys(groupTbl)
		local firstKey = groupKeys[1]
		if firstKey == nil and quietFail then return true end
		local moving = nil
		if type(firstKey) == "number" then 
			moving = table.remove(groupTbl, firstKey)
		else 
			moving = groupTbl[firstKey]
			groupTbl[firstKey] = nil 
		end
		if pairItem == 'k' then moving = firstKey end
		destTbl[destKey] = moving
		return true
	end,
	{ 1, "groupName", "string", false, vital=true },
	{ 2, "destinationName", "string", false, vital=true },
	{ 3, "pairItem", "string", true, default="v" },
	{ 4, "quietFail", "boolean", true, default=false }
)

luaExprFuncs.getStaticVariable = ExprFunc( 
	"getStaticVariable",
	function(inst, state, staticState, varName)
		local varPath = glut.str_split(varName, '.')
		local varKey = table.remove(varPath, #varPath)
		local success, varTbl = glut.tbl_deepget(staticState, false, unpack(varPath))
		if not success then StaticGroupErr(varName) end
		return varTbl[varKey]
	end,
	{ 1, "varName", "string", false, vital=true }
)

luaExprFuncs.fallbackIfUnset = ExprFunc(
	"fallbackIfUnset",
	function(inst, state, staticState, maybeUnset, fallback)
		-- Returns the second argument if the first contains the substring "UNSET" (case-sensitive)
		if maybeUnset == nil then return fallback end
		if type(maybeUnset) ~= "string" then return maybeUnset end
		if glut.str_has_match(maybeUnset, "UNSET") then return fallback end
		if glut.str_has_match(maybeUnset, "DEFAULT") then return fallback end
		return maybeUnset
	end,
	{ 1, "maybeUnset", false, false, default=nil },
	{ 2, "fallback", false, false, default=nil }
)

-- Convenience if you forget the name
luaExprFuncs.fallbackIfDefault = ExprFuncOverload(
	"fallbackIfDefault",
	function(inst, state, staticState, overload, maybeUnset, fallback)
		return overload()
	end,
	{ 1, "maybeUnset", false, false, default=nil },
	{ 2, "fallback", false, false, default=nil }
)

luaExprFuncs.CreateExprFenv = function(inst, instState, staticState)
	return setmetatable(
		{},
		{
			__index = function(t, k)
				if instState[k] ~= nil then return instState[k] end
				if luaExprFuncs[k] == nil then return nil end
				return function(t)
					return luaExprFuncs[k](inst, instState, staticState, t)
				end
			end,
		}
	)
end

return luaExprFuncs]]></ProtectedString>
				<string name="ScriptGuid">{E2794CDD-4304-468F-9705-C61F2BB5BBDA}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">LuaExprFuncs</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
</roblox>