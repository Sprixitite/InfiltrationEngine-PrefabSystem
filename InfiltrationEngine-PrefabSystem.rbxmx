<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBXD21F140C237C47D6B6B14B9C12A686BA">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">InfiltrationEngine-PrefabSystem</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Script" referent="RBX60BB022FEF2A4AD1875FCB2CB012A042">
			<Properties>
				<ProtectedString name="Source"><![CDATA[local warnLogger = require(script.Parent.Slogger).init{
	postInit = table.freeze,
	logFunc = warn
}

local warn = warnLogger.new("PrefabSystem")

local glut = require(script.Parent.GLUt)
glut.configure{ warn = warn }

local apiConsumer = require(script.Parent.APIConsumer)

local luaExpr = require(script.Parent.LuaExpr)
local exprRules = luaExpr.MakeEvalRules("%$%(", "%)")

type APIReference = apiConsumer.APIReference

local hookName = nil
local API_ID = "InfiltrationEngine-PrefabSystem"

local prefabSystem = {}

local function CheckArgCountRange(fname, expectedMin, expectedMax, ...)
	local argCount = select('#', ...)
	if argCount < expectedMin or argCount > expectedMax then
		local expected = (expectedMin == expectedMax) and expectedMin-2 or `{expectedMin-2}-{expectedMax-2}`
		error(`{fname} expects {expected} arguments, but got {argCount}!`)
	end
end

local function CheckArgCount(fname, expected, ...) CheckArgCountRange(fname, expected, expected, ...) end

local PREFAB_IDS = {}
local ELEMENT_IDS = {}

local function GetId(tbl, inst)
	local existing = tbl[inst]
	if existing ~= nil then return existing end
	
	local max = tbl.Total or 0
	tbl[inst] = max
	tbl.Total = max + 1
	return max
end

local function strKeySub(str, key, value)
	key = tostring(key)
	value = tostring(value)
	return string.gsub(str, "([^{]){" .. key .. "}([^}])", function(d1, d2)
		return d1 .. value .. d2
	end)
end

local SPECIAL_FUNCS = {
	this_prop = function(prefab, element, property, ...)
		CheckArgCount("SpecFunc.this", 3, prefab, element, property, ...)
		return element[property]
	end,
	child_prop = function(prefab, element, child, property, ...)
		CheckArgCount("SpecFunc.child", 4, prefab, element, child, property, ...)
		return element:FindFirstChild(child)[property]
	end,
	this_attr = function(prefab, element, attrname, ...)
		CheckArgCount("SpecFunc.this_attr", 3, prefab, element, attrname, ...)
		return element:GetAttribute(attrname)
	end,
	child_attr = function(prefab, element, child, attrname, ...)
		CheckArgCount("SpecFunc.child_attr", 4, prefab, element, child, attrname, ...)
		return element:FindFirstChild(child):GetAttribute(attrname)
	end,
	str_varsub = function(prefab, element, str, ...)
		CheckArgCount("SpecFunc.str_id_sub", 3, prefab, element, str, ...)
		local temp = ` {str} `
		temp = strKeySub(temp, "pid", GetId(PREFAB_IDS, prefab))
		temp = strKeySub(temp, "eid", GetId(ELEMENT_IDS, element))
		temp = strKeySub(temp, "pname", prefab.Name)
		temp = strKeySub(temp, "ename", element.Name)
		temp = strKeySub(temp, "rand", math.random(0, 9999))
		temp = temp:gsub("{{", "{"):gsub("}}", "}"):sub(2, -2)
		return temp
	end,
}

function prefabSystem.OnAPILoaded(api: APIReference, prefabSystemState)
	hookName = api.GetRegistrantFactory("Sprix", "PrefabSystem")
	prefabSystemState.ExportCallbackToken = api.AddHook("PreSerialize", hookName("PreSerialize"), prefabSystem.OnSerializerExport)
end

function prefabSystem.OnAPIUnloaded(api: APIReference, prefabSystemState)
	if prefabSystemState.ExportCallbackToken then
		-- The unload function passed to DoAPILoop is called
		-- both when the API unloads, and when this plugin unloads
		-- as a result, removing any hooks in the unload function is no longer
		-- a "formality", but rather required
		api.RemoveHook(prefabSystemState.ExportCallbackToken)
	end
end

function prefabSystem.OnSerializerExport(hookState: {any}, invokeState: nil, mission: Folder)
	local warn = warnLogger.new("OnSerializerExport")
	local prefabFolder = mission:FindFirstChild("Prefabs")
	if not prefabFolder then return end
	
	local prefabInstanceFolder = mission:FindFirstChild("PrefabInstances")
	if not prefabInstanceFolder then
		-- Prevents prefabs from being exported & wasting space in the mission code
		prefabFolder:Destroy()
		return
	end
	
	local staticStates = {}
	for _, prefabInstance in ipairs(prefabInstanceFolder:GetChildren()) do
		local warn = warn.specialize(`PrefabInstance {prefabInstance.Name} is invalid`)
		
		if not prefabInstance:IsA("BasePart") then
			warn(`Expected BasePart, got {prefabInstance.ClassName}. Skipping.`)
			continue
		end
		
		local prefabInstanceType = prefabInstance:GetAttribute("PrefabName")
		if type(prefabInstanceType) ~= "string" then
			warn(`PrefabName attribute is of wrong datatype or otherwise invalid. Skipping.`)
			continue
		end
		
		local instantiatingPrefab = prefabFolder:FindFirstChild(prefabInstanceType)
		if instantiatingPrefab == nil then
			warn(`PrefabName points to non-existing prefab {prefabInstanceType}. Skipping.`)
			continue
		end
		
		local prefabStatic = staticStates[instantiatingPrefab] or {}
		prefabSystem.InstantiatePrefab(mission, instantiatingPrefab, prefabInstance, prefabStatic)
		staticStates[instantiatingPrefab] = prefabStatic
	end
	
	for _, prefab in ipairs(prefabFolder:GetChildren()) do
		if not prefab:IsA("Folder") then
			warn(`Prefab {prefab.Name} is invalid`, `Expected Folder, got {prefab.ClassName}`, "Prefab Will Be Ignored")
			continue
		end

		local prefabStatic = staticStates[prefab] or {}
		prefabSystem.UnpackPrefab(mission, prefab, "Static", function(mission, prefabTargetGroup)
			prefabSystem.DeepAttributeEvaluator(
				prefab,
				prefabTargetGroup,
				prefabSystem.InterpolateValue,
				{ Instance = prefabStatic, Static = prefabStatic }
			)
		end)
	end
	
	-- Prevent these from being exported and taking up mission space
	prefabFolder:Destroy()
	prefabInstanceFolder:Destroy()
end

function prefabSystem.UnpackPrefab(mission: Folder, prefab: Folder, scope: string, preUnpack)
	preUnpack = glut.default(preUnpack, function() end)
	for _, prefabTargetGroup in ipairs(prefab:GetChildren()) do
		if not prefabTargetGroup:IsA("Folder") then
			warn(`PrefabTargetGroup {prefabTargetGroup.Name} is invalid - expected Folder, got {prefabTargetGroup.ClassName}. Skipping.`)
			continue
		end
		
		if not prefabTargetGroup.Name:lower():find(`^{scope:lower()}`) then continue end
		preUnpack(mission, prefabTargetGroup)
		prefabSystem.UnpackPrefabTargets(mission, prefabTargetGroup)
	end
end

function prefabSystem.UnpackPrefabTargets(mission: Folder, targetGroup: Folder)
	local warn = warnLogger.new("UnpackPrefabTarget", "Prefab Target Invalid")
	
	for _, prefabTarget in ipairs(targetGroup:GetChildren()) do
		if prefabTarget.Name == "InstanceBase" then continue end
		
		if not prefabTarget:IsA("Folder") then
			warn(`Expected Folder, got {prefabTarget.ClassName}`, "Target will be ignored")
			continue
		end

		local missionPrefabTarget = mission:FindFirstChild(prefabTarget.Name) 
		if missionPrefabTarget == nil then warn(`Destination {prefabTarget.Name} not present`, "Create it if needed") continue end
		for _, prefabTargetItem in ipairs(prefabTarget:GetChildren()) do
			prefabTargetItem:Clone().Parent = missionPrefabTarget 
		end
	end
end

function prefabSystem.InstantiatePrefab(mission: Folder, prefab: Folder, prefabInstance: BasePart, staticState)
	local warn = warnLogger.new("InstantiatePrefab", `Prefab {prefab.Name}`)
	
	local instanceTargetGroup = prefab:FindFirstChild("Instance") or prefab:FindFirstChild("instance")
	if not instanceTargetGroup then
		warn("Prefab may not be instantiated!")
		return
	end
	
	local instanceData = instanceTargetGroup:Clone()
	local instanceBase = instanceData:FindFirstChild("InstanceBase")
	if not instanceBase then
		warn("Instance folder found but no InstanceBase part present!")
		return
	end
	
	if not instanceBase:IsA("Part") then
		warn("InstanceBase found but not a part!")
		return
	end
	
	local sFuncStructure = prefabSystem.CollectSpecFuncAttrs(prefab, instanceBase, SPECIAL_FUNCS)
	prefabSystem.EvaluateSpecFuncs(prefab, prefabInstance, SPECIAL_FUNCS, sFuncStructure)
	
	local instanceSettings = instanceBase:GetAttributes()
	for settingName, instanceValue in pairs(prefabInstance:GetAttributes()) do
		local warn = warn.specialize(`Ignoring invalid attribute {settingName}`)
		
		if settingName == "PrefabName" then continue end
		
		local defaultValue = instanceSettings[settingName] 
		
		if type(defaultValue) == "string" then
			local isSFunc = prefabSystem.StrIsSpecFunc(defaultValue)
			if isSFunc then instanceSettings[settingName] = instanceValue continue end
		end
		
		if defaultValue == nil then
			warn("Attribute not present on InstanceBase")
			continue
		end
		
		if type(defaultValue) ~= type(instanceValue) then
			warn(`Expected type {type(defaultValue)} but got {type(instanceValue)}`)
			continue
		end
		
		instanceSettings[settingName] = instanceValue
	end
	
	local cfrSet = prefabSystem.DeepAttributeEvaluator(
		prefab,
		instanceData,
		prefabSystem.InterpolateValue, 
		{ Instance = instanceSettings, Static = staticState }
	)
	
	for _, prefabElement in pairs(instanceData:GetDescendants()) do
		if prefabElement == instanceBase then continue end
		if not prefabElement:IsA("BasePart") then continue end
		if cfrSet[prefabElement] then continue end
		local baseToElement = instanceBase.CFrame:ToObjectSpace(prefabElement.CFrame)
		prefabElement.CFrame = prefabInstance.CFrame:ToWorldSpace(baseToElement)
	end
	
	prefabSystem.UnpackPrefabTargets(mission, instanceData)
end

function prefabSystem.DeepAttributeEvaluator(prefab: Folder, root: Instance, evaluator, evalData)
	local warn = warnLogger.new("Attribute Evaluation", `{root.Parent}.{root}`)
	
	local whoSetCfr = {}
	for attrName, attrValue in pairs(root:GetAttributes()) do
		if type(attrValue) ~= "string" then continue end
		local success, interpolatedAttrValue = evaluator(prefab, root, attrName, attrValue, evalData)
		if not success then
			warn(interpolatedAttrValue, "Attribute will be ignored")
			root:SetAttribute(attrName, nil)
			continue
		end
		
		local ignoreName = attrName:match("^ignore%.([_%w]+)$")
		if ignoreName ~= nil then
			root:SetAttribute(attrName, nil)
			continue
		end
		
		local propName = attrName:match("^this%.([_%w]+)$")
		if propName ~= nil then
			local success, reason = pcall(function()
				root[propName] = interpolatedAttrValue
			end)
			if not success then
				warn(`Failed to set Property {propName}`, reason) 
			end
			whoSetCfr[root] = whoSetCfr[root] or propName == "CFrame"
			root:SetAttribute(attrName, nil)
			continue
		end
		
		root:SetAttribute(attrName, interpolatedAttrValue)
	end
	
	local success, interpolatedName = evaluator(prefab, root, `{root}.Name`, root.Name, evalData)
	if success and type(interpolatedName) == "string" then
		root.Name = interpolatedName
	elseif success then
		warn("Name evaluation resolved to a non-string value")
	end
	
	for _, child in ipairs(root:GetChildren()) do
		local childSet = prefabSystem.DeepAttributeEvaluator(prefab, child, evaluator, evalData)
		for inst, set in pairs(childSet) do
			whoSetCfr[inst] = set
		end
	end
	
	return whoSetCfr
end

function prefabSystem.CreateShebangFenv(state, staticState)
	local fenvBase = {
		state = state,
		staticState = staticState,
		math = math,
		string = string,
		CFrame = CFrame,
		Color3 = Color3,
		Vector2 = Vector2,
		Vector3 = Vector3,
		tostring = tostring,
		tonumber = tonumber,
		pairs = pairs,
		ipairs = ipairs,
		next = next,
		print = print
	}
	
	-- state can't overshadow builtin libraries
	setmetatable(fenvBase, { __index = state })
	return fenvBase
end

function prefabSystem.InterpolateValue(prefab: Folder, element: Instance, name: string, value: string, state: { [string] : any }) : any
	local exprName = `{element.Parent}.{element}:{name}`
	local warn = warnLogger.new("Attribute Interpolation", exprName)
	
	local instState = state.Instance
	local staticState = state.Static
	
	local shebangContents = string.match(value, "^#!/lua%s+(.*)$")
	if shebangContents ~= nil then
		local warn = warn.specialize("ShebangScriptExec")
		local success, count, args = glut.str_runlua(
			shebangContents,
			prefabSystem.CreateShebangFenv(instState, staticState),
			exprName
		)
		
		if not success then
			return success, count
		end
		
		if count > 1 then
			warn(`Script execution succeeded, but {count-1} extra values were returned`, "Extra values will be ignored")
		elseif count == 0 then
			warn("Script execution succeeded, but no value was returned", "Attribute will be ignored")
			return false, nil
		end
		return success, args[1]
	end
	
	local success, evalResult = luaExpr.Eval(value, instState, exprRules, exprName, false)
	
	if not success then
		if type(evalResult) == "string" then
			warn(evalResult)
		end
		evalResult = nil
	end

	return success, evalResult
end

function prefabSystem.CollectSpecFuncAttrs(prefab, root, sfuncs)
	local selfTbl = { Attributes = {}, Children = {} }
	
	for attrName, attrVal in pairs(root:GetAttributes()) do
		if type(attrVal) ~= "string" then continue end
		local success, sfuncData = prefabSystem.ParseSpecFunc(prefab, root, attrVal, sfuncs)
		if not success then continue end
		
		selfTbl.Attributes[attrName] = sfuncData
	end
	
	for _, baseElem in ipairs(root:GetChildren()) do
		selfTbl.Children[baseElem.Name] = prefabSystem.CollectSpecFuncAttrs(prefab, baseElem, sfuncs)
	end
	
	return selfTbl
end

function prefabSystem.EvaluateSpecFuncs(prefab, root, sfuncs, data)
	local warn = warnLogger.new("EvaluateSpecFuncs")
	
	for childName, childData in pairs(data.Children) do
		local childInstance = root:FindFirstChild(childName)
		if childInstance == nil then warn(`Expected instance {root.Name}.{childName} not found`) continue end
		prefabSystem.EvaluateSpecFuncs(prefab, childInstance, sfuncs, childData)
	end

	for attrName, sFuncData in pairs(data.Attributes) do
		if root:GetAttribute(attrName) ~= nil then continue end
		local success, result = prefabSystem.EvaluateSpecFunc(prefab, root, sFuncData)
		if not success then continue end
		root:SetAttribute(attrName, result)
	end
end

local SPECFUNCS_SUBSTITUTION_PATTERN = "%${(.+)}"
function prefabSystem.StrIsSpecFunc(str)
	local sfuncContent = string.match(str, `^{SPECFUNCS_SUBSTITUTION_PATTERN}$`)
	return sfuncContent ~= nil, sfuncContent
end

function prefabSystem.ParseSpecFunc(prefab, element, sfuncStr, sfuncs)
	local warn = warnLogger.new("SFuncParsing", `{element.Parent.Name}.{element.Name}`, sfuncStr)
	
	local isSfunc, sfuncContent = prefabSystem.StrIsSpecFunc(sfuncStr)
	if not isSfunc then return false, nil end

	local sfuncArgs = {}
	local sfuncCurrentArg = ""
	local escaping = false
	local inStr = false
	for c in string.gmatch(sfuncContent, ".") do
		if c:match("^%s$") and not inStr then continue end
		if c == "\\" and not escaping then escaping = true continue end
		if c == "\"" and not escaping and not inStr then inStr = true continue end
		if c == "\"" and not escaping and inStr then inStr = false continue end

		if c == "," and not escaping and not inStr then
			table.insert(sfuncArgs, sfuncCurrentArg)
			sfuncCurrentArg = ""
			continue
		end

		if c == 'n' and escaping then
			sfuncCurrentArg = sfuncCurrentArg .. "\n"
		elseif c == 't' and escaping then
			sfuncCurrentArg = sfuncCurrentArg .. "\t"
		elseif escaping then
			warn(`Received unknown escape \"\\{c}\", ignoring backslash and treating as a normal character`)
			sfuncCurrentArg = sfuncCurrentArg .. c
		else
			sfuncCurrentArg = sfuncCurrentArg .. c
		end

		escaping = false
	end
	table.insert(sfuncArgs, sfuncCurrentArg)

	local sfuncExpectedType = table.remove(sfuncArgs, 1)
	local sfuncName = table.remove(sfuncArgs, 1)
	local sfunc = sfuncs[sfuncName]
	if sfunc == nil then
		warn(`SpecialFunc \"{sfuncName}\" not found!`)
		return false, nil
	end
	
	return true, {
		Func = sfunc,
		Name = sfuncName,
		Args = sfuncArgs,
		Type = sfuncExpectedType,
		Expr = sfuncContent
	}
end

function prefabSystem.EvaluateSpecFunc(prefab, element, sfuncData)
	local warn = warnLogger.new("SFuncExec", sfuncData.Expr, sfuncData.Name)
	
	local success, result = pcall(sfuncData.Func, prefab, element, unpack(sfuncData.Args))
	if success and typeof(result) == sfuncData.Type then return success, result end
	if not success then
		warn(`Execution failed with reason \"{result}\"`)
		return success, result
	end
	
	warn(`Executed successfully but did not return expected type {sfuncData.Type}`)
	return false, nil
end

apiConsumer.DoAPILoop(plugin, API_ID, prefabSystem.OnAPILoaded, prefabSystem.OnAPIUnloaded)]]></ProtectedString>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{2EFB673D-CAA3-471F-972B-512807FDA430}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Main</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXADA13D450364427D854CDF875F51620C">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[--[[
	This module is provided for convenience of consumers of the serializer API
	providing a reference implementation for correctly retrieving and validating a reference to the API table

	For a working example of a plugin making use of this API via this module
	see: https://github.com/Sprixitite/InfiltrationEngine-PrefabSystem
]]

local coreGui = game:GetService("CoreGui")

export type Token = string
export type Hook = (...any) -> nil
export type HookType = "APIExtensionLoaded"|"APIExtensionUnloaded"|"PreSerialize"|"PreSerializeMissionSetup"|"SerializerUnloaded"
export type APIExtension = { [string] : (...any) -> ...any }

export type APIReference = {
	-- Generic
	GetAPIVersion 			: () -> number,
	GetCodeVersion 			: () -> number,
	GetAttributesMap 		: () -> { [string] : { [number] : any } },
	GetAttributeTypes 		: () -> { [string] : number },
	GetRegistrantFactory	: (author: string, plugin: string) -> ((hookName: string) -> string), 

	-- HookTypes
	GetHookTypes 			: () -> { [number] : string },
	IsHookTypeValid 		: (hookType: string, warnCaller: string?) -> boolean,

	-- Hooks
	AddHook 				: (hookType: HookType, registrant: string, hook: Hook, hookState: {any}?) -> Token,
	RemoveHook 				: (token: Token) -> nil,

	-- APIExtensions
	AddAPIExtension 		: (name: string, author: string, contents: APIExtension) -> Token,
	GetAPIExtension			: (name: string, author: string) -> APIExtension,
	RemoveAPIExtension		: (token: Token) -> nil
}

type AnyTbl = { [string] : any }

local APIConsumer = {}

local function ValidateArgTypes(fname: string, ...) : boolean
	local args = {...}
	for _, argSettings in ipairs(args) do
		local argName = argSettings[1]
		local argValue = argSettings[2]
		local argType = type(argValue)
		local argExpectedType = argSettings[3]
		if argType ~= argExpectedType then
			warn(`Invalid argument {argName} passed to function {fname} - expected type {argExpectedType} but got {argType}!`)
			return false
		end
	end
	return true
end

APIConsumer.ValidateArgTypes = ValidateArgTypes

-- Yields until timeOut is elapsed or API is found
APIConsumer.WaitForAPI = function(timeOut: number?) : APIReference?
	timeOut = if timeOut == nil then math.huge else timeOut

	if not ValidateArgTypes(
		"WaitForAPI",
		{"timeOut", timeOut, "number"}
		) then return end

	local presenceIndicator = coreGui:WaitForChild("InfilEngine_SerializerAPIAvailable", timeOut)
	if not presenceIndicator then return end

	local apiTbl = shared.InfilEngine_SerializerAPI
	if not (tostring(apiTbl) == presenceIndicator.Value) then return end

	return apiTbl
end

-- Attempt to get the API without blocking - returns false + nil if unavailable, otherwise returns true + APIReference
APIConsumer.TryGetAPI = function() : (boolean, APIReference?)
	local presenceIndicator = coreGui:FindFirstChild("InfilEngine_SerializerAPIAvailable")
	if not presenceIndicator then return false, nil end

	local apiTbl = shared.InfilEngine_SerializerAPI
	if not (tostring(apiTbl) == presenceIndicator.Value) then return false, nil end

	return true, apiTbl
end

-- Never returns unless there's an error
-- Continually wires up handling of serializer load/unload as well as unloading of consumer plugin as needed
-- Avoid doing this yourself if you can help it
APIConsumer.DoAPILoop = function<StateT>(
	callerPlugin: Plugin,
	srcname: string,
	loadedClbck: (api: APIReference, state: StateT) -> nil,
	unloadedClbck: (api: APIReference, state: StateT) -> nil, 
	state: StateT?
) : never
	state = if state == nil then {} else state

	if typeof(callerPlugin) ~= "Instance" then
		warn(`Invalid argument callerPlugin passed to DoAPILoop - expected type Plugin but got {typeof(callerPlugin)}!`)
		return
	end

	if callerPlugin.ClassName ~= "Plugin" then
		warn(`Invalid argument callerPlugin passed to DoAPILoop - expected type Plugin but got {callerPlugin.ClassName}!`)
		return
	end

	if not ValidateArgTypes(
		"DoAPILoop", 
		{"srcname", srcname, "string"},
		{"loadedClbck", loadedClbck, "function"},
		{"unloadedClbck", unloadedClbck, "function"},
		{"state", state, "table"}
		) then return end

	local api = APIConsumer.WaitForAPI()
	if api == nil then return APIConsumer.DoAPILoop(callerPlugin, srcname, loadedClbck, unloadedClbck, state) end

	loadedClbck(api, state)

	local pluginUnloadCallback
	local unloadToken

	pluginUnloadCallback = callerPlugin.Unloading:Connect(function()
		pluginUnloadCallback:Disconnect()
		pluginUnloadCallback = nil
		unloadedClbck(api, state)
		if unloadToken ~= nil then api.RemoveHook(unloadToken) end
	end)

	unloadToken = api.AddHook("SerializerUnloaded", `APIConsumerFramework_{srcname}`, function()
		if pluginUnloadCallback then pluginUnloadCallback:Disconnect() pluginUnloadCallback = nil end
		unloadedClbck(api, state)
		task.spawn(APIConsumer.DoAPILoop, callerPlugin, srcname, loadedClbck, unloadedClbck, state)
	end)
end

return APIConsumer]]></ProtectedString>
				<string name="ScriptGuid">{9C413FEA-27C9-4E1A-A9CC-E7239C0F162A}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">APIConsumer</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX108B9E44DDDE466FB5D5578EB3B9C351">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[--[[
	Slogger, yet another minimal Lua logging module
	Log function + post-init function are configurable, for dealing with the slog that is lua version compatibility
	
	Tested to be compatible with Lua5.1
	Presumed compatible with Lua5.2-5.5/Luajit/Luau
	
	© Sprixitite, 2025
]]

local slogger = {}

local sloggerCfg = {
	postInit = function(tbl) return tbl end,
	logFunc = print
}

local function varargs(...)
	local argCount = select('#', ...)
	local argTbl = { ... }
	local i = 0
	return function()
		i = i + 1
		if i <= argCount then return i, argTbl[i], argCount end
	end, argTbl
end

function slogger.new(...)
	local loggerPrefix = ""
	local varargsIter, argsTbl = varargs(...)
	
	for i, arg in varargsIter do
		loggerPrefix = loggerPrefix .. tostring(arg) .. " : "
	end
	
	local doWarn = function(tbl, ...)
		local finalMsg = ""
		
		for i, arg, argCount in varargs(...) do
			finalMsg = finalMsg .. tostring(arg)
			if i ~= argCount then
				finalMsg = finalMsg .. " : "
			end
		end
		
		sloggerCfg.logFunc(loggerPrefix .. finalMsg)
	end
	
	local specialize = function(...)
		return slogger.new(unpack(argsTbl), ...)
	end
	
	local newLogger = setmetatable({ specialize = specialize }, {__call = doWarn})
	return sloggerCfg.postInit(newLogger)
end

function slogger.init(cfg)
	for k, v in pairs(cfg) do
		if type(sloggerCfg[k]) == type(v) then
			sloggerCfg[k] = v
		end
	end
	return slogger
end

return slogger]]></ProtectedString>
				<string name="ScriptGuid">{9A026DAB-AF18-4CD8-98AE-F24BAF01A1ED}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Slogger</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXB54D6E3C7EC2447DB47911D899A8D4F6">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[local glut = require(script.Parent.GLUt)

local LuaExpr = {}

local LUA_EXPR_BODY_STRMATCH = "([\'\"%-%+%*%^%.,:/_%w%s]+)"

function LuaExpr.MakeEvalRules(prefix, delim)
	local bodyMatch = prefix .. LUA_EXPR_BODY_STRMATCH .. delim 
	return {
		BodyMatch = bodyMatch,
		SoleMatch = '^' .. bodyMatch .. '$'
	}
end

local LUA_EXPR_MATCH_DEFAULT = LuaExpr.MakeEvalRules("%$%(", "%)")

function LuaExpr.IsSoleExpr(str, rules)
	local soleExprData = string.match(str, rules.SoleMatch)
	return soleExprData ~= nil, soleExprData
end

function LuaExpr.EvalSoleExpr(str, fenv, rules, exprName, multiRet)
	exprName = glut.default_typed(exprName, "LUAEXPR_UNNAMED", "exprName", "LuaExpr.EvalSoleExpr")
	multiRet = glut.default_typed(multiRet, false, "multiRet", "LuaExpr.EvalSoleExpr")
	
	local leadingReturn = string.match(str, "^return%s+")
	if leadingReturn == nil then str = "return " .. str end
	
	local success, count, args = glut.str_runlua(str, fenv, exprName)
	if not success then
		return false, "LuaExpr : " .. exprName .. " : Evaluation failed : " .. count
	end
	
	return success, args[1]
end

function LuaExpr.Eval(str, fenv, rules, exprName, soleOnly)
	if not glut.type_check(str, "string", "str", "LuaExpr.Eval") then return end
	if not glut.type_check(fenv, "table", "fenv", "LuaExpr.Eval") then return end
	
	rules = glut.default_typed(rules, LUA_EXPR_MATCH_DEFAULT, "rules", "LuaExpr.Eval")
	exprName = glut.default_typed(exprName, "LUAEXPR_UNNAMED", "epxrName", "LuaExpr.Eval")
	soleOnly = glut.default_typed(soleOnly, false, "soleOnly", "LuaExpr.Eval")
	
	local isSole, soleData = LuaExpr.IsSoleExpr(str, rules)
	if isSole then return LuaExpr.EvalSoleExpr(soleData, fenv, rules, exprName, isSole) end
	if soleOnly then return false, nil end
	
	local i = 0
	return true, string.gsub(str, rules.BodyMatch, function(subexpr)
		i = i+1
		local subExprName = exprName .. '#' .. tostring(i)
		local evalSuccess, evalVal = LuaExpr.EvalSoleExpr(subexpr, fenv, rules, subExprName, false)
		return tostring(evalVal)
	end)
end

return LuaExpr]]></ProtectedString>
				<string name="ScriptGuid">{DE119178-750B-474C-BF0B-A605B90864FB}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">LuaExpr</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXB2503E1B2E2C4856B599D1F9AD98C84D">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[--[[
	GLUt // GoodLuaUtilities // Lua5.1 utilities module
	
	© Sprixitite, 2025
]]

local GLUt = {}

local GLUtCfg = {
	print = print,
	warn  = function(...) print("WARNING", ...) end,
	error = error,
	type  = type
}

local patternSpecChars = { '(', ')', '.', '%', '+', '-', '*', '?', '[', ']', '^', '$' }

function GLUt.configure(tbl)
	for k, v in pairs(tbl) do
		if GLUtCfg[k] ~= nil then
			GLUtCfg[k] = v
		else
			GLUtCfg.warn("Attempt to set invalid GLUtCfg Key \"" .. tostring(k) .. "\"")
		end
	end
end

function GLUt.default(arg, default)
	return (arg == nil) and default or arg
end

function GLUt.default_exec(arg, fn)
	return (arg == nil) and fn() or arg
end

function GLUt.default_typed(arg, default, argName, funcName)
	local argType = GLUtCfg.type(arg)
	local defaultType = GLUtCfg.type(default)
	if argType == defaultType then return arg end
	if argType == "nil" then return default end
	GLUt.type_warn(argName, funcName, defaultType, argType)
	return default
end

function GLUt.type_warn(argName, funcName, expected, got)
	if argName == nil or expected == got then return end
	
	local warnStart = GLUt.type_is(funcName, "string") and (funcName .. ": expected arg \"") or "Expected arg \""
	GLUtCfg.warn(warnStart .. argName .. "\" of type \"" .. expected .. "\" got type \"" .. got .. "\"!")
	GLUtCfg.warn("Traceback: " .. debug.traceback())
end

function GLUt.type_check(arg, expected, argName, funcName)
	local argType = GLUtCfg.type(arg)
	
	expected = string.gsub(expected, '?', "|nil")
	for _, validType in pairs(GLUt.str_split(expected, '|')) do
		if validType == argType then return true end
	end
	
	GLUt.type_warn(argName, funcName, expected, argType)
	
	return false
end

function GLUt.type_is(a1, t)
	return GLUtCfg.type(a1) == t
end

function GLUt.type_eq(a1, a2)
	return GLUtCfg.type(a1) == GLUtCfg.type(a2)
end

function GLUt.vararg_capture(...)
	local n = select('#', ...)
	return n, { ... }
end

function GLUt.vararg_iter(...)
	local n, t = GLUt.vararg_capture(...)
	local i = 0
	return function()
		i = i + 1
		if i <= n then return i, t[i], n end
	end, t
end

function GLUt.str_split(str, separator)
	str = str .. separator
	separator = GLUt.str_escape_pattern(separator)
	
	local substrs = {}
	for substr in string.gmatch(str, "(.-)" .. separator) do
		substrs[#substrs+1] = substr
	end
	return substrs
end

function GLUt.str_escape_pattern(str)
	local escaped = str
	for _, specChar in ipairs(patternSpecChars) do
		local escapedSpec = '%' .. specChar
		escaped = string.gsub(escaped, escapedSpec, (specChar == '%') and "%%" or '%' .. escapedSpec)
	end
	return escaped
end

function GLUt.str_double_substr(str, substr)
	local safe = GLUt.str_escape_pattern(substr)
	return string.gsub(str, safe, safe .. safe)
end

function GLUt.str_isempty(str)
	return string.match(str, "^%s$") ~= nil
end

function GLUt.str_chariter(str)
	local n = #str
	local i = 0
	return function()
		i = i + 1
		if i <= n then return GLUt.str_getchar(str, i) end
	end
end

function GLUt.str_getchar(str, i)
	return string.sub(str, i, i)
end

local unidentified = -1
function GLUt.str_runlua(source, fenv, chunkName)
	chunkName = GLUt.default_exec(chunkName, function()
		unidentified = unidentified + 1
		return "loadstring#" .. tostring(unidentified) 
	end)
	
	local strFun, failReason = loadstring(source, chunkName)
	if GLUtCfg.type(strFun) ~= "function" then
		return false, "Loadstring : " .. chunkName .. " : Evaluation failed : " .. failReason
	end
	strFun = setfenv(strFun, fenv)
	
	return pcall(function()
		return GLUt.vararg_capture(strFun())
	end)
end

function GLUt.kvp_tostring(k, v)
	return tostring(k) .. " = " .. tostring(v)
end

function GLUt.tbl_tryindex(tbl, ...)
	local indexing = tbl
	for _, k in GLUt.vararg_iter(...) do
		if GLUtCfg.type(indexing) ~= "table" then
			return false, indexing
		end
		indexing = indexing[tostring(k)]
	end

	return true, indexing
end

function GLUt.tbl_clone(tbl, shallow)
	shallow = GLUt.default(shallow, false)
	
	local cloned = {}
	for k, v in pairs(tbl) do
		if GLUtCfg.type(v) == "table" and not shallow then
			cloned[k] = GLUt.tbl_clone(v, shallow)
		else
			cloned[k] = v
		end
	end
	return cloned
end

function GLUt.tbl_findsize(tbl)
	local i = 0
	for _, _ in pairs(tbl) do i = i + 1 end
	return i
end

local function tbl_tostring(tblName, tbl, levels, level)
	local str = tblName .. " = {"
	local indent = string.rep("  ", level)
	local n = GLUt.tbl_findsize(tbl)
	local i = 0
	for k, v in pairs(tbl) do
		i = i + 1
		str = str .. '\n' .. indent
		if GLUtCfg.type(v) == "table" and levels > level then
			str = str .. tbl_tostring(k, v, levels, level+1)
		else
			str = str .. GLUt.kvp_tostring(k, v)
		end
		if i < n then str = str .. ',' end
	end
	return str
end

function GLUt.tbl_tostring(tbl, levels, tblName)
	GLUt.default(tblName, tostring(tbl))
	return tbl_tostring(tblName, tbl, levels, 1)
end

return GLUt]]></ProtectedString>
				<string name="ScriptGuid">{7484DC6C-C136-46C9-992B-BD6809BF968D}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">GLUt</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
</roblox>