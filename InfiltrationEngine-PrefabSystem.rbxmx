<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBXED07DD1581814A7FBC76785607E08BA1">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">InfiltrationEngine-PrefabSystem</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Script" referent="RBX8BB0DB8B1E8B4D57AA807D2A1EF40275">
			<Properties>
				<ProtectedString name="Source"><![CDATA[local apiConsumer = require(script.Parent.APIConsumer)
local warnLogger = require(script.Parent.Slogger).init{
	postInit = table.freeze,
	logFunc = warn
}

type APIReference = apiConsumer.APIReference

local API_ID = "InfiltrationEngine-PrefabSystem"

local prefabSystem = {}

local function CheckArgCountRange(fname, expectedMin, expectedMax, ...)
	local argCount = select('#', ...)
	if argCount < expectedMin or argCount > expectedMax then
		local expected = (expectedMin == expectedMax) and expectedMin-2 or `{expectedMin-2}-{expectedMax-2}`
		error(`{fname} expects {expected} arguments, but got {argCount}!`)
	end
end

local function CheckArgCount(fname, expected, ...) CheckArgCountRange(fname, expected, expected, ...) end

local PREFAB_IDS = {}
local ELEMENT_IDS = {}

local function GetId(tbl, inst)
	local existing = tbl[inst]
	if existing ~= nil then return existing end
	
	local max = tbl.Total or 0
	tbl[inst] = max
	tbl.Total = max + 1
	return max
end

local function strKeySub(str, key, value)
	key = tostring(key)
	value = tostring(value)
	return string.gsub(str, "([^{]){" .. key .. "}([^}])", function(d1, d2)
		return d1 .. value .. d2
	end)
end

local SPECIAL_FUNCS = {
	this_prop = function(prefab, element, property, ...)
		CheckArgCount("SpecFunc.this", 3, prefab, element, property, ...)
		return element[property]
	end,
	child_prop = function(prefab, element, child, property, ...)
		CheckArgCount("SpecFunc.child", 4, prefab, element, child, property, ...)
		return element:FindFirstChild(child)[property]
	end,
	this_attr = function(prefab, element, attrname, ...)
		CheckArgCount("SpecFunc.this_attr", 3, prefab, element, attrname, ...)
		return element:GetAttribute(attrname)
	end,
	child_attr = function(prefab, element, child, attrname, ...)
		CheckArgCount("SpecFunc.child_attr", 4, prefab, element, child, attrname, ...)
		return element:FindFirstChild(child):GetAttribute(attrname)
	end,
	str_varsub = function(prefab, element, str, ...)
		CheckArgCount("SpecFunc.str_id_sub", 3, prefab, element, str, ...)
		local temp = ` {str} `
		temp = strKeySub(temp, "pid", GetId(PREFAB_IDS, prefab))
		temp = strKeySub(temp, "eid", GetId(ELEMENT_IDS, element))
		temp = strKeySub(temp, "pname", prefab.Name)
		temp = strKeySub(temp, "ename", element.Name)
		temp = strKeySub(temp, "rand", math.random(0, 9999))
		temp = temp:gsub("{{", "{"):gsub("}}", "}"):sub(2, -2)
		return temp
	end,
}

function prefabSystem.OnAPILoaded(api: APIReference, prefabSystemState)
	prefabSystemState.ExportCallbackToken = api.AddHook("PreSerialize", API_ID, prefabSystem.OnSerializerExport)
end

function prefabSystem.OnAPIUnloaded(api: APIReference, prefabSystemState)
	if prefabSystemState.ExportCallbackToken then
		-- The unload function passed to DoAPILoop is called
		-- both when the API unloads, and when this plugin unloads
		-- as a result, removing any hooks in the unload function is no longer
		-- a "formality", but rather required
		api.RemoveHook(prefabSystemState.ExportCallbackToken)
	end
end

function prefabSystem.OnSerializerExport(hookState: {any}, invokeState: nil, mission: Folder)
	local warn = warnLogger.new("OnSerializerExport")
	local prefabFolder = mission:FindFirstChild("Prefabs")
	if not prefabFolder then return end
	
	for _, prefab in ipairs(prefabFolder:GetChildren()) do
		if not prefab:IsA("Folder") then
			warn(`Prefab {prefab.Name} is invalid`, `Expected Folder, got {prefab.ClassName}`, "Prefab Will Be Ignored")
			continue
		end
		
		prefabSystem.UnpackPrefab(mission, prefab, "Static")
	end
	
	local prefabInstanceFolder = mission:FindFirstChild("PrefabInstances")
	if not prefabInstanceFolder then
		-- Prevents prefabs from being exported & wasting space in the mission code
		prefabFolder:Destroy()
		return
	end
	
	for _, prefabInstance in ipairs(prefabInstanceFolder:GetChildren()) do
		local warn = warn.specialize(`PrefabInstance {prefabInstance.Name} is invalid`)
		
		if not prefabInstance:IsA("BasePart") then
			warn(`Expected BasePart, got {prefabInstance.ClassName}. Skipping.`)
			continue
		end
		
		local prefabInstanceType = prefabInstance:GetAttribute("PrefabName")
		if type(prefabInstanceType) ~= "string" then
			warn(`PrefabName attribute is of wrong datatype or otherwise invalid. Skipping.`)
			continue
		end
		
		local instantiatingPrefab = prefabFolder:FindFirstChild(prefabInstanceType)
		if instantiatingPrefab == nil then
			warn(`PrefabName points to non-existing prefab {prefabInstanceType}. Skipping.`)
			continue
		end
		
		prefabSystem.InstantiatePrefab(mission, instantiatingPrefab, prefabInstance)
	end
	
	-- Prevent these from being exported and taking up mission space
	prefabFolder:Destroy()
	prefabInstanceFolder:Destroy()
end

function prefabSystem.UnpackPrefab(mission: Folder, prefab: Folder, scope: string)
	for _, prefabTargetGroup in ipairs(prefab:GetChildren()) do
		if not prefabTargetGroup:IsA("Folder") then
			warn(`PrefabTargetGroup {prefabTargetGroup.Name} is invalid - expected Folder, got {prefabTargetGroup.ClassName}. Skipping.`)
			continue
		end
		
		if not prefabTargetGroup.Name:lower():find(`^{scope:lower()}`) then continue end
		prefabSystem.UnpackPrefabTargets(mission, prefabTargetGroup)
	end
end

function prefabSystem.UnpackPrefabTargets(mission: Folder, targetGroup: Folder)
	local warn = warnLogger.new("UnpackPrefabTarget", "Prefab Target Invalid")
	
	for _, prefabTarget in ipairs(targetGroup:GetChildren()) do
		if prefabTarget.Name == "InstanceBase" then continue end
		
		if not prefabTarget:IsA("Folder") then
			warn(`Expected Folder, got {prefabTarget.ClassName}`, "Target will be ignored")
			continue
		end

		local missionPrefabTarget = mission:FindFirstChild(prefabTarget.Name) 
		if missionPrefabTarget == nil then warn(`Destination {prefabTarget.Name} not present`, "Create it if needed") continue end
		for _, prefabTargetItem in ipairs(prefabTarget:GetChildren()) do
			prefabTargetItem:Clone().Parent = missionPrefabTarget 
		end
	end
end

function prefabSystem.InstantiatePrefab(mission: Folder, prefab: Folder, prefabInstance: BasePart)
	local warn = warnLogger.new("InstantiatePrefab", `Prefab {prefab.Name}`)
	
	local instanceTargetGroup = prefab:FindFirstChild("Instance") or prefab:FindFirstChild("instance")
	if not instanceTargetGroup then
		warn("Prefab may not be instantiated!")
		return
	end
	
	local instanceData = instanceTargetGroup:Clone()
	local instanceBase = instanceData:FindFirstChild("InstanceBase")
	if not instanceBase then
		warn("Instance folder found but no InstanceBase part present!")
		return
	end
	
	if not instanceBase:IsA("Part") then
		warn("InstanceBase found but not a part!")
		return
	end
	
	local sFuncStructure = prefabSystem.CollectSpecFuncAttrs(prefab, instanceBase, SPECIAL_FUNCS)
	prefabSystem.EvaluateSpecFuncs(prefab, prefabInstance, SPECIAL_FUNCS, sFuncStructure)
	
	local instanceSettings = instanceBase:GetAttributes()
	for settingName, instanceValue in pairs(prefabInstance:GetAttributes()) do
		local warn = warn.specialize(`Ignoring invalid attribute {settingName}`)
		
		if settingName == "PrefabName" then continue end
		
		local isSFunc = prefabSystem.StrIsSpecFunc(instanceSettings[settingName])
		if isSFunc then instanceSettings[settingName] = instanceValue continue end
		
		local defaultValue = instanceSettings[settingName] 
		if defaultValue == nil then
			warn("Attribute not present on InstanceBase")
			continue
		end
		
		if type(defaultValue) ~= type(instanceValue) then
			warn(`Expected type {type(defaultValue)} but got {type(instanceValue)}`)
			continue
		end
		
		instanceSettings[settingName] = instanceValue
	end
	
	local cfrSet = prefabSystem.DeepAttributeEvaluator(prefab, instanceData, prefabSystem.InterpolateValue, instanceSettings)
	
	for _, prefabElement in pairs(instanceData:GetDescendants()) do
		if prefabElement == instanceBase then continue end
		if not prefabElement:IsA("BasePart") then continue end
		if cfrSet[prefabElement] then continue end
		local baseToElement = instanceBase.CFrame:ToObjectSpace(prefabElement.CFrame)
		prefabElement.CFrame = prefabInstance.CFrame:ToWorldSpace(baseToElement)
	end
	
	prefabSystem.UnpackPrefabTargets(mission, instanceData)
end

function prefabSystem.DeepAttributeEvaluator(prefab: Folder, root: Instance, evaluator, evalData)
	local warn = warnLogger.new("Attribute Evaluation", `{root.Parent}.{root}`)
	
	local whoSetCfr = {}
	for attrName, attrValue in pairs(root:GetAttributes()) do
		if type(attrValue) ~= "string" then continue end
		local success, interpolatedAttrValue = evaluator(prefab, root, attrValue, evalData)
		if not success then continue end
		
		local propName = attrName:match("^this%.([_%w]+)$")
		if propName ~= nil then
			local success = pcall(function()
				root[propName] = interpolatedAttrValue
			end)
			if not success then
				warn(`Property {propName} not present on instance`) 
			end
			whoSetCfr[root] = propName == "CFrame"
			root:SetAttribute(attrName, nil)
			continue
		end
		
		root:SetAttribute(attrName, interpolatedAttrValue)
	end
	
	local success, interpolatedName = evaluator(prefab, root, root.Name, evalData)
	if success and type(interpolatedName) == "string" then
		root.Name = interpolatedName
	elseif success then
		warn("Name evaluation resolved to a non-string value")
	end
	
	for _, child in ipairs(root:GetChildren()) do
		local childSet = prefabSystem.DeepAttributeEvaluator(prefab, child, evaluator, evalData)
		for inst, set in pairs(childSet) do
			whoSetCfr[inst] = set
		end
	end
	
	return whoSetCfr
end

local ATTRIBUTE_SUBSTITUTION_PATTERN = "%$%(([_%w]+)%)"
function prefabSystem.InterpolateValue(prefab: Folder, element: Instance, value: string, state: { [string] : any }) : any
	local warn = warnLogger.new("Attribute Interpolation", `{element.Parent}.{element}`)
	
	local fullReplaceName = string.match(value, `^{ATTRIBUTE_SUBSTITUTION_PATTERN}$`)
	if fullReplaceName ~= nil then
		local fullReplaceValue = state[fullReplaceName]
		if fullReplaceValue == nil then
			warn(`Full-Substitute variable \"{fullReplaceName}\" not found!`)
			return false, nil
		end
		return true, fullReplaceValue
	end

	return true, string.gsub(value, ATTRIBUTE_SUBSTITUTION_PATTERN, function(subName)
		local subValue = state[subName]
		if subValue == nil then
			warn(`Partial-Substitute variable \"{subName}\" not found!`)
		end
		return tostring(subValue) or `ATTRSUB_FAIL_{subName}_NOTFOUND`
	end)
end

function prefabSystem.CollectSpecFuncAttrs(prefab, root, sfuncs)
	local selfTbl = { Attributes = {}, Children = {} }
	
	for attrName, attrVal in pairs(root:GetAttributes()) do
		local success, sfuncData = prefabSystem.ParseSpecFunc(prefab, root, attrVal, sfuncs)
		if not success then continue end
		
		selfTbl.Attributes[attrName] = sfuncData
	end
	
	for _, baseElem in ipairs(root:GetChildren()) do
		selfTbl.Children[baseElem.Name] = prefabSystem.CollectSpecFuncAttrs(prefab, baseElem, sfuncs)
	end
	
	return selfTbl
end

function prefabSystem.EvaluateSpecFuncs(prefab, root, sfuncs, data)
	local warn = warnLogger.new("EvaluateSpecFuncs")
	
	for childName, childData in pairs(data.Children) do
		local childInstance = root:FindFirstChild(childName)
		if childInstance == nil then warn(`Expected instance {root.Name}.{childName} not found`) continue end
		prefabSystem.EvaluateSpecFuncs(prefab, childInstance, sfuncs, childData)
	end

	for attrName, sFuncData in pairs(data.Attributes) do
		local success, result = prefabSystem.EvaluateSpecFunc(prefab, root, sFuncData)
		if not success then continue end
		root:SetAttribute(attrName, result)
	end
end

local SPECFUNCS_SUBSTITUTION_PATTERN = "%${(.+)}"
function prefabSystem.StrIsSpecFunc(str)
	local sfuncContent = string.match(str, `^{SPECFUNCS_SUBSTITUTION_PATTERN}$`)
	return sfuncContent ~= nil, sfuncContent
end

function prefabSystem.ParseSpecFunc(prefab, element, sfuncStr, sfuncs)
	local warn = warnLogger.new("SFuncParsing", `{element.Parent.Name}.{element.Name}`, sfuncStr)
	
	local isSfunc, sfuncContent = prefabSystem.StrIsSpecFunc(sfuncStr)
	if isSfunc == nil then return false, nil end

	local sfuncArgs = {}
	local sfuncCurrentArg = ""
	local escaping = false
	local inStr = false
	for c in string.gmatch(sfuncContent, ".") do
		if c:match("^%s$") and not inStr then continue end
		if c == "\\" and not escaping then escaping = true continue end
		if c == "\"" and not escaping and not inStr then inStr = true continue end
		if c == "\"" and not escaping and inStr then inStr = false continue end

		if c == "," and not escaping and not inStr then
			table.insert(sfuncArgs, sfuncCurrentArg)
			sfuncCurrentArg = ""
			continue
		end

		if c == 'n' and escaping then
			sfuncCurrentArg = sfuncCurrentArg .. "\n"
		elseif c == 't' and escaping then
			sfuncCurrentArg = sfuncCurrentArg .. "\t"
		elseif escaping then
			warn(`Received unknown escape \"\\{c}\", ignoring backslash and treating as a normal character`)
			sfuncCurrentArg = sfuncCurrentArg .. c
		else
			sfuncCurrentArg = sfuncCurrentArg .. c
		end

		escaping = false
	end
	table.insert(sfuncArgs, sfuncCurrentArg)

	local sfuncExpectedType = table.remove(sfuncArgs, 1)
	local sfuncName = table.remove(sfuncArgs, 1)
	local sfunc = sfuncs[sfuncName]
	if sfunc == nil then
		warn(`SpecialFunc \"{sfuncName}\" not found!`)
		return false, nil
	end
	
	return true, {
		Func = sfunc,
		Name = sfuncName,
		Args = sfuncArgs,
		Type = sfuncExpectedType,
		Expr = sfuncContent
	}
end

function prefabSystem.EvaluateSpecFunc(prefab, element, sfuncData)
	local warn = warnLogger.new("SFuncExec", sfuncData.Expr, sfuncData.Name)
	
	local success, result = pcall(sfuncData.Func, prefab, element, unpack(sfuncData.Args))
	if success and typeof(result) == sfuncData.Type then return success, result end
	if not success then
		warn(`Execution failed with reason \"{result}\"`)
		return success, result
	end
	
	warn(`Executed successfully but did not return expected type {sfuncData.Type}`)
	return false, nil
end

apiConsumer.DoAPILoop(plugin, API_ID, prefabSystem.OnAPILoaded, prefabSystem.OnAPIUnloaded)]]></ProtectedString>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{2EFB673D-CAA3-471F-972B-512807FDA430}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Main</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX49FCF3076B7545F68AD91D4A68C92B7A">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[--[[
	This module is provided for convenience of consumers of the serializer API
	providing a reference implementation for correctly retrieving and validating a reference to the API table

	For a working example of a plugin making use of this API via this module
	see: https://github.com/Sprixitite/InfiltrationEngine-PrefabSystem
]]

local coreGui = game:GetService("CoreGui")

export type Token = string
export type Hook = (...any) -> nil
export type HookType = "APIExtensionLoaded"|"APIExtensionUnloaded"|"PreSerialize"|"SerializerUnloaded"
export type APIExtension = { [string] : (...any) -> ...any }

export type APIReference = {
	-- Generic
	GetAPIVersion 		: () -> number,
	GetCodeVersion 		: () -> number,
	GetAttributesMap 	: () -> { [string] : { [number] : any } },
	GetAttributeTypes 	: () -> { [string] : number },

	-- HookTypes
	GetHookTypes 		: () -> { [number] : string },
	IsHookTypeValid 	: (hookType: string, warnCaller: string?) -> boolean,

	-- Hooks
	AddHook 			: (hookType: HookType, registrant: string, hook: Hook, hookState: {any}?) -> Token,
	RemoveHook 			: (token: Token) -> nil,

	-- APIExtensions
	AddAPIExtension 	: (name: string, author: string, contents: APIExtension) -> Token,
	GetAPIExtension		: (name: string, author: string) -> APIExtension,
	RemoveAPIExtension	: (token: Token) -> nil
}

type AnyTbl = { [string] : any }

local APIConsumer = {}

local function ValidateArgTypes(fname: string, ...) : boolean
	local args = {...}
	for _, argSettings in ipairs(args) do
		local argName = argSettings[1]
		local argValue = argSettings[2]
		local argType = type(argValue)
		local argExpectedType = argSettings[3]
		if argType ~= argExpectedType then
			warn(`Invalid argument {argName} passed to function {fname} - expected type {argExpectedType} but got {argType}!`)
			return false
		end
	end
	return true
end

APIConsumer.ValidateArgTypes = ValidateArgTypes

-- Yields until timeOut is elapsed or API is found
APIConsumer.WaitForAPI = function(timeOut: number?) : APIReference?
	timeOut = if timeOut == nil then math.huge else timeOut

	if not ValidateArgTypes(
		"WaitForAPI",
		{"timeOut", timeOut, "number"}
		) then return end

	local presenceIndicator = coreGui:WaitForChild("InfilEngine_SerializerAPIAvailable", timeOut)
	if not presenceIndicator then return end

	local apiTbl = shared.InfilEngine_SerializerAPI
	if not (tostring(apiTbl) == presenceIndicator.Value) then return end

	return apiTbl
end

-- Never returns unless there's an error
-- Continually wires up handling of serializer load/unload as well as unloading of consumer plugin as needed
-- Avoid doing this yourself if you can help it
APIConsumer.DoAPILoop = function<StateT>(
	callerPlugin: Plugin,
	srcname: string,
	loadedClbck: (api: APIReference, state: StateT) -> nil,
	unloadedClbck: (api: APIReference, state: StateT) -> nil, 
	state: StateT?
) : never
	state = if state == nil then {} else state

	if typeof(callerPlugin) ~= "Instance" then
		warn(`Invalid argument callerPlugin passed to DoAPILoop - expected type Plugin but got {typeof(callerPlugin)}!`)
		return
	end

	if callerPlugin.ClassName ~= "Plugin" then
		warn(`Invalid argument callerPlugin passed to DoAPILoop - expected type Plugin but got {callerPlugin.ClassName}!`)
		return
	end

	if not ValidateArgTypes(
		"DoAPILoop", 
		{"srcname", srcname, "string"},
		{"loadedClbck", loadedClbck, "function"},
		{"unloadedClbck", unloadedClbck, "function"},
		{"state", state, "table"}
		) then return end

	local api = APIConsumer.WaitForAPI()
	if api == nil then return APIConsumer.DoAPILoop(callerPlugin, srcname, loadedClbck, unloadedClbck, state) end

	loadedClbck(api, state)

	local pluginUnloadCallback

	pluginUnloadCallback = callerPlugin.Unloading:Connect(function()
		pluginUnloadCallback:Disconnect()
		pluginUnloadCallback = nil
		unloadedClbck(api, state)
	end)

	api.AddHook("SerializerUnloaded", `APIConsumerFramework_{srcname}`, function()
		if pluginUnloadCallback then pluginUnloadCallback:Disconnect() pluginUnloadCallback = nil end
		unloadedClbck(api, state)
		APIConsumer.DoAPILoop(callerPlugin, srcname, loadedClbck, unloadedClbck, state)
	end)
end

return APIConsumer]]></ProtectedString>
				<string name="ScriptGuid">{9C413FEA-27C9-4E1A-A9CC-E7239C0F162A}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">APIConsumer</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXC60B8FC568F247F89DD735F2AAF9FF65">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[--[[
	Slogger, yet another minimal Lua logging module
	Log function + post-init function are configurable, for dealing with the slog that is lua version compatibility
	
	Tested to be compatible with Lua5.1
	Presumed compatible with Lua5.2-5.5/Luajit/Luau
	
	Â© Sprixitite, 2025
]]

local slogger = {}

local sloggerCfg = {
	postInit = function(tbl) return tbl end,
	logFunc = print
}

local function varargs(...)
	local argCount = select('#', ...)
	local argTbl = { ... }
	local i = 0
	return function()
		i = i + 1
		if i <= argCount then return i, argTbl[i], argCount end
	end, argTbl
end

function slogger.new(...)
	local loggerPrefix = ""
	local varargsIter, argsTbl = varargs(...)
	
	for i, arg in varargsIter do
		loggerPrefix = loggerPrefix .. tostring(arg) .. " : "
	end
	
	local doWarn = function(tbl, ...)
		local finalMsg = ""
		
		for i, arg, argCount in varargs(...) do
			finalMsg = finalMsg .. tostring(arg)
			if i ~= argCount then
				finalMsg = finalMsg .. " : "
			end
		end
		
		sloggerCfg.logFunc(loggerPrefix .. finalMsg)
	end
	
	local specialize = function(...)
		return slogger.new(unpack(argsTbl), ...)
	end
	
	local newLogger = setmetatable({ specialize = specialize }, {__call = doWarn})
	return sloggerCfg.postInit(newLogger)
end

function slogger.init(cfg)
	for k, v in pairs(cfg) do
		if type(sloggerCfg[k]) == type(v) then
			sloggerCfg[k] = v
		end
	end
	return slogger
end

return slogger]]></ProtectedString>
				<string name="ScriptGuid">{952CD0D0-51F6-4816-983D-89B1B2D599FD}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Slogger</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
</roblox>