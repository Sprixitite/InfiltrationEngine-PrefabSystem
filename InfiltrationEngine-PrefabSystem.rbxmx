<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBX0DA1522B043047E29C0A8DE4A16526B0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">InfiltrationEngine-PrefabSystem</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Script" referent="RBX64069B9995574B18BC6CFD5D62CE6E1F">
			<Properties>
				<ProtectedString name="Source"><![CDATA[local warnLogger = require(script.Parent.Slogger).init{
	postInit = table.freeze,
	logFunc = warn
}

local warn = warnLogger.new("PrefabSystem")

local glut = require(script.Parent.GLUt)
glut.configure{ warn = warn }

local apiConsumer = require(script.Parent.APIConsumer)

local luaExpr = require(script.Parent.LuaExpr)
local luaExprFuncs = require(script.Parent.LuaExprFuncs)
local shebangFuncs = require(script.Parent.ShebangFuncs)
local exprRules = luaExpr.MakeEvalRules("%$%(", "%)")

type APIReference = apiConsumer.APIReference

local hookName = nil
local API_ID = "InfiltrationEngine-PrefabSystem"

local prefabSystem = {}

local function CheckArgCountRange(fname, expectedMin, expectedMax, ...)
	local argCount = select('#', ...)
	if argCount < expectedMin or argCount > expectedMax then
		local expected = (expectedMin == expectedMax) and expectedMin-2 or `{expectedMin-2}-{expectedMax-2}`
		error(`{fname} expects {expected} arguments, but got {argCount}!`)
	end
end

local function CheckArgCount(fname, expected, ...) CheckArgCountRange(fname, expected, expected, ...) end

local PREFAB_IDS = {}
local ELEMENT_IDS = {}

local function GetId(tbl, inst)
	local existing = tbl[inst]
	if existing ~= nil then return existing end
	
	local max = tbl.Total or 0
	tbl[inst] = max
	tbl.Total = max + 1
	return max
end

local function strKeySub(str, key, value)
	key = tostring(key)
	value = tostring(value)
	return string.gsub(str, "([^{]){" .. key .. "}([^}])", function(d1, d2)
		return d1 .. value .. d2
	end)
end

local SPECIAL_FUNCS = {
	this_prop = function(prefab, element, property, ...)
		CheckArgCount("SpecFunc.this", 3, prefab, element, property, ...)
		return element[property]
	end,
	child_prop = function(prefab, element, child, property, ...)
		CheckArgCount("SpecFunc.child", 4, prefab, element, child, property, ...)
		return element:FindFirstChild(child)[property]
	end,
	this_attr = function(prefab, element, attrname, ...)
		CheckArgCount("SpecFunc.this_attr", 3, prefab, element, attrname, ...)
		return element:GetAttribute(attrname)
	end,
	child_attr = function(prefab, element, child, attrname, ...)
		CheckArgCount("SpecFunc.child_attr", 4, prefab, element, child, attrname, ...)
		return element:FindFirstChild(child):GetAttribute(attrname)
	end,
	str_varsub = function(prefab, element, str, ...)
		CheckArgCount("SpecFunc.str_id_sub", 3, prefab, element, str, ...)
		local temp = ` {str} `
		temp = strKeySub(temp, "pid", GetId(PREFAB_IDS, prefab))
		temp = strKeySub(temp, "eid", GetId(ELEMENT_IDS, element))
		temp = strKeySub(temp, "pname", prefab.Name)
		temp = strKeySub(temp, "ename", element.Name)
		temp = strKeySub(temp, "rand", math.random(0, 9999))
		temp = temp:gsub("{{", "{"):gsub("}}", "}"):sub(2, -2)
		return temp
	end,
}

function prefabSystem.OnAPILoaded(api: APIReference, prefabSystemState)
	prefabSystemState.Hooks = prefabSystemState.Hooks or {}
	prefabSystemState.ExtHooks = prefabSystemState.ExtHooks or {}
	prefabSystemState.ApiExtensions = prefabSystemState.ApiExtensions or {}
	prefabSystem.OnAPIUnloaded(api, prefabSystemState)
	
	hookName = api.GetRegistrantFactory("Sprix", "PrefabSystem")
	local attributeImporterAPI = api.GetAPIExtension("AttributeImporter", "Sprix")
	if attributeImporterAPI then
		prefabSystem.OnAPIExtensionLoaded(prefabSystemState, nil, "AttributeImporter", "Sprix", attributeImporterAPI)
	end
	
	prefabSystemState.Hooks[1] = api.AddHook("PreSerialize", hookName("PreSerialize"), prefabSystem.OnSerializerExport)
	prefabSystemState.Hooks[2] = api.AddHook("APIExtensionLoaded", hookName("APIExtensionLoaded"), prefabSystem.OnAPIExtensionLoaded, prefabSystemState)
	prefabSystemState.Hooks[3] = api.AddHook("APIExtensionUnloaded", hookName("APIExtensionUnloaded"), prefabSystem.OnAPIExtensionUnloaded, prefabSystemState)
end

function prefabSystem.ImportAttributesForPrefab(prefabName)
	local warn = warn.specialize("AttributeImport")
	
	local mission = workspace:FindFirstChild("DebugMission")
	if mission == nil then
		warn("No Mission folder found!")
	end
	
	local prefabs = mission:FindFirstChild("Prefabs")
	
	if prefabs == nil then
		warn("No Prefabs folder found!")
		return {} 
	end
	
	local prefab = nil
	for _, potentialPrefab in ipairs(prefabs:GetChildren()) do
		if potentialPrefab.Name ~= prefabName then continue end
		prefab = potentialPrefab
	end
	
	if prefab == nil then
		warn(`Prefab {prefabName} not found!`)
		return {} 
	end
	
	local instance = prefab:FindFirstChild("Instance")
	if instance == nil then
		warn(`Failed to find instance scope for Prefab {prefabName}`)
		return {} 
	end
	
	local instanceBase = instance:FindFirstChild("InstanceBase")
	if instanceBase == nil then
		warn(`Failed to find InstanceBase for Prefab {prefabName}`)
		return {}
	end
	
	local importing = {}
	for attrName, attrDefault in pairs(instanceBase:GetAttributes()) do
		if glut.str_has_match(attrName, "^noimp%.") then continue end
		importing[attrName] = { type(attrDefault), attrDefault }
	end
	
	return importing
end

function prefabSystem.OnAPIExtensionLoaded(prefabSystemState, _, name, author, contents)
	if author ~= "Sprix" or name ~= "AttributeImporter" then return end
	prefabSystemState.ExtHooks[1] = {
		Name = "AttributeImporter",
		Auth = "Sprix",
		Dereg = "RemoveAbstractionImporter",
		Token = contents.AddAbstractionImporter(
			"PrefabSystem",
			require("./AttributeImporterSearchInfo"),
			prefabSystem.ImportAttributesForPrefab
		)	
	}
end

local extHookIter = glut.custom_iter_template("Name", "Auth", "Dereg", "Token")
function prefabSystem.OnAPIExtensionUnloaded(prefabSystemState, _, name, author, contents)
	local removing = {}
	for i, extName, extAuth, extDereg, extToken in extHookIter(prefabSystemState.ExtHooks) do
		if name ~= extName or author ~= extAuth then continue end
		if contents[extDereg] == nil then continue end
		contents[extDereg](extToken)
		removing[#removing] = i
	end
	for idx=#removing, 1, -1 do
		table.remove(prefabSystemState.ExtHooks, removing[idx])
	end 
end

function prefabSystem.OnAPIUnloaded(api: APIReference, prefabSystemState)
	for _, token in ipairs(prefabSystemState.Hooks) do
		api.RemoveHook(token)
	end
	for i, extName, extAuth, extDereg, extToken in extHookIter(prefabSystemState.ExtHooks) do
		local ext = api.GetAPIExtension(extName, extAuth)
		if ext == nil then continue end
		if ext[extDereg] == nil then continue end
		ext[extDereg](extToken)
	end
	for _, extToken in ipairs(prefabSystemState.ApiExtensions) do
		api.RemoveAPIExtension(extToken)
	end
end

function prefabSystem.OnSerializerExport(hookState: {any}, invokeState, mission: Folder)
	local warn = warnLogger.new("OnSerializerExport")
	
	local prefabFolder = mission:FindFirstChild("Prefabs")
	if not prefabFolder then return end
	
	local first = true
	repeat
		if not first then coroutine.yield() end
		local _, present = invokeState.Get("Sprix_AttributeAuditor_PreSerialize_Present")
		local success, done = invokeState.Get("Sprix_AttributeAuditor_PreSerialize", "Done")
		first = false
	until (not present) or (success and done)
	
	if workspace:GetAttribute("EmeraldMode") then
		print("Hi i'm prefabsystem :3")
	end
	
	local prefabInstanceFolder = mission:FindFirstChild("PrefabInstances")
	if not prefabInstanceFolder then
		-- Prevents prefabs from being exported & wasting space in the mission code
		prefabFolder:Destroy()
		return
	end

	local globalState = table.freeze({})
	local staticStates = {}
	local prefabInstances = prefabInstanceFolder:GetDescendants()
	local i = 1
	while i <= #prefabInstances do
		local prefabInstance = prefabInstances[i]
		i = i + 1
		
		local warn = warn.specialize(`PrefabInstance {prefabInstance.Name} is invalid`)
		
		if prefabInstance:IsA("Folder") then continue end
		if prefabInstance.Parent:IsA("BasePart") then continue end
		
		if not prefabInstance:IsA("BasePart") then
			warn(`Expected BasePart, got {prefabInstance.ClassName}. Skipping.`)
			continue
		end
		
		local prefabInstanceType = prefabInstance:GetAttribute("PrefabName")
		if type(prefabInstanceType) ~= "string" then
			warn(`PrefabName attribute is of wrong datatype or otherwise invalid. Skipping.`)
			continue
		end
		
		local instantiatingPrefab = prefabFolder:FindFirstChild(prefabInstanceType)
		if instantiatingPrefab == nil then
			warn(`PrefabName points to non-existing prefab {prefabInstanceType}. Skipping.`)
			continue
		end
		
		local prefabStatic = staticStates[instantiatingPrefab] or {}
		prefabSystem.InstantiatePrefab(mission, instantiatingPrefab, prefabInstance, prefabStatic, globalState)
		staticStates[instantiatingPrefab] = prefabStatic
		for _, i in ipairs(prefabInstanceFolder:GetDescendants()) do
			if not table.find(prefabInstances, i) then prefabInstances[#prefabInstances+1] = i end
		end
	end
	
	for _, prefab in ipairs(prefabFolder:GetChildren()) do
		if not prefab:IsA("Folder") then
			warn(`Prefab {prefab.Name} is invalid`, `Expected Folder, got {prefab.ClassName}`, "Prefab Will Be Ignored")
			continue
		end

		local prefabStatic = staticStates[prefab] or {}
		prefabSystem.UnpackPrefab(mission, prefab, "Static", function(mission, prefabTargetGroup)
			prefabSystem.DeepAttributeEvaluator(
				prefab,
				prefabTargetGroup,
				prefabSystem.InterpolateValue,
				{ Instance = prefabStatic, Static = prefabStatic, Global = globalState }
			)
		end)
		
	end
	
	-- Prevent these from being exported and taking up mission space
	prefabFolder:Destroy()
	prefabInstanceFolder:Destroy()
end

function prefabSystem.UnpackPrefab(mission: Folder, prefab: Folder, scope: string, preUnpack)
	preUnpack = glut.default(preUnpack, function() end)
	for _, prefabTargetGroup in ipairs(prefab:GetChildren()) do
		if not prefabTargetGroup:IsA("Folder") then
			warn(`PrefabTargetGroup {prefabTargetGroup.Name} is invalid - expected Folder, got {prefabTargetGroup.ClassName}. Skipping.`)
			continue
		end
		
		if not prefabTargetGroup.Name:lower():find(`^{scope:lower()}`) then continue end
		local modifiedTargets = preUnpack(mission, prefabTargetGroup) or {prefabTargetGroup}
		for _, modifiedTarget in ipairs(modifiedTargets) do
			prefabSystem.UnpackPrefabTargets(mission, modifiedTarget)
		end
	end
end

function prefabSystem.UnpackPrefabTargets(mission: Folder, targetGroup: Folder)
	local warn = warnLogger.new("UnpackPrefabTarget", "Prefab Target Invalid")
	
	for _, prefabTarget in ipairs(targetGroup:GetChildren()) do
		if prefabTarget.Name == "InstanceBase" then continue end
		
		if prefabTarget:IsA("ValueBase") then
			continue
		end
		
		if not prefabTarget:IsA("Folder") then
			warn(`Expected Folder, got {prefabTarget.ClassName}`, "Target will be ignored")
			continue
		end

		local missionPrefabTarget = mission:FindFirstChild(prefabTarget.Name) 
		if missionPrefabTarget == nil then warn(`Destination {prefabTarget.Name} not present`, "Create it if needed") continue end
		for _, prefabTargetItem in ipairs(prefabTarget:GetChildren()) do
			local itemIsFolder = prefabTargetItem:IsA("Folder")
			local missionFolder = missionPrefabTarget:FindFirstChild(prefabTargetItem.Name)
			if itemIsFolder and missionFolder ~= nil then
				for _, child in ipairs(prefabTargetItem:GetChildren()) do
					child:Clone().Parent = missionFolder
				end
				continue
			end
			prefabTargetItem:Clone().Parent = missionPrefabTarget 
		end
	end
end

function prefabSystem.InstantiatePrefab(mission: Folder, prefab: Folder, prefabInstance: BasePart, staticState, globalState)
	local warn = warn.specialize("InstantiatePrefab", `Prefab {prefab.Name}`)
	
	local instanceTargetGroup = prefab:FindFirstChild("Instance") or prefab:FindFirstChild("instance")
	if not instanceTargetGroup then
		warn("Prefab may not be instantiated!")
		return
	end
	
	local instanceData = instanceTargetGroup:Clone()
	local instanceBase = instanceData:FindFirstChild("InstanceBase")
	if not instanceBase then
		warn("Instance folder found but no InstanceBase part present!")
		return
	end
	
	if not instanceBase:IsA("Part") then
		warn("InstanceBase found but not a part!")
		return
	end
	
	local sFuncStructure = prefabSystem.CollectSpecFuncAttrs(prefab, instanceBase, SPECIAL_FUNCS)
	prefabSystem.EvaluateSpecFuncs(prefab, prefabInstance, SPECIAL_FUNCS, sFuncStructure)
	
	local instanceSettings = {}
	for k, v in pairs(instanceBase:GetAttributes()) do
		instanceSettings[k:gsub("^noimp%.", "")] = v
	end
	
	for settingName, instanceValue in pairs(prefabInstance:GetAttributes()) do
		local warn = warn.specialize(`Ignoring invalid attribute {settingName}`)
		
		if settingName == "PrefabName" then continue end
		
		settingName = string.gsub(settingName, "^noimp%.", "")
		local defaultValue = instanceSettings[settingName] 
		
		if type(defaultValue) == "string" then
			local isSFunc = prefabSystem.StrIsSpecFunc(defaultValue)
			if isSFunc then instanceSettings[settingName] = instanceValue continue end
		end
		
		if defaultValue == nil then
			warn("Attribute not present on InstanceBase")
			continue
		end
		
		if type(defaultValue) ~= type(instanceValue) then
			warn(`Expected type {type(defaultValue)} but got {type(instanceValue)}`)
			continue
		end
		
		instanceSettings[settingName] = instanceValue
	end
	
	local cfrSet = prefabSystem.DeepAttributeEvaluator(
		prefab,
		instanceData,
		prefabSystem.InterpolateValue,
		{ Instance = instanceSettings, Static = staticState, Global = globalState },
		{ "this.CFrame" }
	)["this.CFrame"] or {}
	staticState.Attrs = staticState.Attrs or {}
	staticState.Attr = staticState.Attrs
	local staticAttrs = staticState.Attrs
	for k, v in pairs(instanceSettings) do
		staticAttrs[k] = staticAttrs[k] or {}
		local attrTbl = staticAttrs[k]
		table.insert(attrTbl, v)
	end
	
	for _, prefabElement in pairs(instanceData:GetDescendants()) do
		if prefabElement == instanceBase then continue end
		if not prefabElement:IsA("BasePart") then continue end
		if cfrSet[prefabElement] ~= nil then continue end
		local baseToElement = instanceBase.CFrame:ToObjectSpace(prefabElement.CFrame)
		prefabElement.CFrame = prefabInstance.CFrame:ToWorldSpace(baseToElement)
	end
	
	prefabSystem.UnpackPrefabTargets(mission, instanceData)
end

function prefabSystem.GetSortedAttributeList(instance)
	local instanceAttrs = instance:GetAttributes()
	local instanceAttrNames = {}
	for k, _ in pairs(instanceAttrs) do table.insert(instanceAttrNames, k) end
	
	table.sort(instanceAttrNames, function(a, b)
		local aIsHighP = string.match(a, "^highp%.") ~= nil
		local bIsHighP = string.match(b, "^highp%.") ~= nil
		local aIsLowP = string.match(a, "^lowp%.") ~= nil
		local bIsLowP = string.match(b, "^lowp%.") ~= nil
		
		local aNumericP = string.match(a, "^(%d+)%.")
		local bNumericP = string.match(b, "^(%d+)%.")
		local aIsNumericP = aNumericP ~= nil
		local bIsNumericP = bNumericP ~= nil
		
		if aIsNumericP and bIsNumericP then
			return tonumber(aNumericP) < tonumber(bNumericP)
		elseif aIsNumericP then
			return true
		elseif bIsNumericP then
			return false
		end
		
		if aIsHighP and not bIsHighP then
			return true
		elseif bIsHighP and not aIsHighP then
			return false
		elseif aIsLowP and not bIsLowP then
			return false
		elseif bIsLowP and not aIsLowP then
			return true
		else
			return a < b
		end
	end)
	
	return instanceAttrNames
end

function prefabSystem.IsProgrammable(inst)
	for n, _ in pairs(inst:GetAttributes()) do
		if glut.str_has_match(n, "ProgrammableDone$") then return true end
	end
	return false
end

function prefabSystem.DeepAttributeEvaluator(prefab: Folder, root: Instance, evaluator, evalData, attrCapture, programmableRecurse)
	attrCapture = glut.default(attrCapture, {})
	programmableRecurse = glut.default(programmableRecurse, false)
	local warn = warnLogger.new("Attribute Evaluation", `{root.Parent}.{root}`)
	
	if prefabSystem.IsProgrammable(root) and not programmableRecurse then
		local evalLimit = root:GetAttribute("ignore.ProgrammableEvalLimit")
		if type(evalLimit) ~= "number" then evalLimit = 2000 end
		
		local attrCapture = glut.tbl_clone(attrCapture)
		local allCaptured = {}
		if not table.find(attrCapture, "ignore.ProgrammableDone") then table.insert(attrCapture, "ignore.ProgrammableDone") end
		local i = 0
		repeat
			i = i + 1
			local rootClone = root:Clone()
			rootClone.Parent = root.Parent
			local setQuery = prefabSystem.DeepAttributeEvaluator(
				prefab,
				rootClone,
				evaluator,
				evalData,
				attrCapture,
				true
			)
			local doneSet = setQuery["ignore.ProgrammableDone"][rootClone]
			if doneSet then rootClone:Destroy() end
			allCaptured = glut.tbl_merge(allCaptured, setQuery)
		until doneSet or i >= evalLimit
		if i >= evalLimit then
			warn(
				`Error evaluating programmable instance - did not finish after {evalLimit} evaluations`,
				"If intentional - this limit may be altered by setting \"ignore.ProgrammableEvalLimit\" to a number of your choosing"
			)
		end
		root:Destroy()
		return allCaptured
	end
	
	local setQuery = {}
	for _, attrName in ipairs(prefabSystem.GetSortedAttributeList(root)) do
		local attrValue = root:GetAttribute(attrName)
		if type(attrValue) ~= "string" then continue end
		local success, interpolatedAttrValue = evaluator(prefab, root, attrName, attrValue, evalData)
		if not success then
			warn(interpolatedAttrValue, "Attribute will be ignored")
			root:SetAttribute(attrName, nil)
			continue
		end
		
		local pName = attrName:match("^highp%.(.+)$") or attrName:match("^lowp%.(.+)$") or attrName:match("^%d+%.(.+)$")
		if pName ~= nil then
			root:SetAttribute(attrName, nil)
			attrName = pName
		end
		
		for _, querying in ipairs(attrCapture) do
			if attrName == querying then
				setQuery[querying] = setQuery[querying] or {}
				setQuery[querying][root] = interpolatedAttrValue
			end
		end
		
		local ignoreName = attrName:match("^ignore%.([_%w]+)$")
		if ignoreName ~= nil then
			root:SetAttribute(attrName, nil)
			continue
		end
		
		local propName = attrName:match("^this%.([_%w]+)$")
		if propName ~= nil then
			local success, reason = pcall(function()
				if typeof(root[propName]) == "EnumItem" then
					interpolatedAttrValue = root[propName].EnumType:FromName(interpolatedAttrValue)
				end
				root[propName] = interpolatedAttrValue
			end)
			if not success then
				warn(`Failed to set Property {propName}`, reason) 
			end
			root:SetAttribute(attrName, nil)
			continue
		end
		
		root:SetAttribute(attrName, interpolatedAttrValue)
	end
	
	local success, interpolatedName = evaluator(prefab, root, `{root}.Name`, root.Name, evalData)
	if success and type(interpolatedName) == "string" then
		root.Name = interpolatedName
	elseif success then
		warn("Name evaluation resolved to a non-string value")
	end
	
	for _, child in ipairs(root:GetChildren()) do
		local childSet = prefabSystem.DeepAttributeEvaluator(prefab, child, evaluator, evalData, attrCapture, programmableRecurse)
		for attrName, hit in pairs(childSet) do
			setQuery[attrName] = setQuery[attrName] or {}
			local subTbl = setQuery[attrName]
			for inst, val in pairs(hit) do
				subTbl[inst] = val
			end
		end
	end
	
	return setQuery
end

function prefabSystem.InterpolateValue(prefab: Folder, element: Instance, name: string, value: string, state: { [string] : any }) : any
	local exprName = `{element.Parent}.{element}:{name}`
	local warn = warnLogger.new("Attribute Interpolation", exprName)
	
	local instState = state.Instance
	local staticState = state.Static
	local globalState = state.Global
	
	local shebangContents = string.match(value, "^#!/lua%s+(.*)$")
	if shebangContents ~= nil then
		local warn = warn.specialize("ShebangScriptExec")
		local success, count, args = glut.str_runlua(
			shebangContents,
			shebangFuncs.CreateShebangFenv(element, instState, staticState, globalState),
			exprName
		)
		
		if not success then
			return success, count
		end
		
		if count > 1 then
			warn(`Script execution succeeded, but {count-1} extra values were returned`, "Extra values will be ignored")
		elseif count == 0 then
			warn("Script execution succeeded, but no value was returned", "Attribute will be ignored")
			return false, nil
		end
		return success, args[1]
	end
	
	local success, evalResult = luaExpr.Eval(
		value,
		luaExprFuncs.CreateExprFenv(element, instState, staticState),
		exprRules,
		exprName,
		false
	)
	
	if not success then
		if type(evalResult) == "string" then
			warn(evalResult)
		end
		evalResult = nil
	end

	return success, evalResult
end

function prefabSystem.CollectSpecFuncAttrs(prefab, root, sfuncs)
	local selfTbl = { Attributes = {}, Children = {} }
	
	for attrName, attrVal in pairs(root:GetAttributes()) do
		if type(attrVal) ~= "string" then continue end
		local success, sfuncData = prefabSystem.ParseSpecFunc(prefab, root, attrVal, sfuncs)
		if not success then continue end
		
		selfTbl.Attributes[attrName] = sfuncData
	end
	
	for _, baseElem in ipairs(root:GetChildren()) do
		selfTbl.Children[baseElem.Name] = prefabSystem.CollectSpecFuncAttrs(prefab, baseElem, sfuncs)
	end
	
	return selfTbl
end

function prefabSystem.EvaluateSpecFuncs(prefab, root, sfuncs, data)
	local warn = warnLogger.new("EvaluateSpecFuncs")
	
	for childName, childData in pairs(data.Children) do
		local childInstance = root:FindFirstChild(childName)
		if childInstance == nil then warn(`Expected instance {root.Name}.{childName} not found`) continue end
		prefabSystem.EvaluateSpecFuncs(prefab, childInstance, sfuncs, childData)
	end

	for attrName, sFuncData in pairs(data.Attributes) do
		if root:GetAttribute(attrName) ~= nil then continue end
		local success, result = prefabSystem.EvaluateSpecFunc(prefab, root, sFuncData)
		if not success then continue end
		root:SetAttribute(attrName, result)
	end
end

local SPECFUNCS_SUBSTITUTION_PATTERN = "%${(.+)}"
function prefabSystem.StrIsSpecFunc(str)
	local sfuncContent = string.match(str, `^{SPECFUNCS_SUBSTITUTION_PATTERN}$`)
	return sfuncContent ~= nil, sfuncContent
end

function prefabSystem.ParseSpecFunc(prefab, element, sfuncStr, sfuncs)
	local warn = warnLogger.new("SFuncParsing", `{element.Parent.Name}.{element.Name}`, sfuncStr)
	
	local isSfunc, sfuncContent = prefabSystem.StrIsSpecFunc(sfuncStr)
	if not isSfunc then return false, nil end

	local sfuncArgs = {}
	local sfuncCurrentArg = ""
	local escaping = false
	local inStr = false
	for c in string.gmatch(sfuncContent, ".") do
		if c:match("^%s$") and not inStr then continue end
		if c == "\\" and not escaping then escaping = true continue end
		if c == "\"" and not escaping and not inStr then inStr = true continue end
		if c == "\"" and not escaping and inStr then inStr = false continue end

		if c == "," and not escaping and not inStr then
			table.insert(sfuncArgs, sfuncCurrentArg)
			sfuncCurrentArg = ""
			continue
		end

		if c == 'n' and escaping then
			sfuncCurrentArg = sfuncCurrentArg .. "\n"
		elseif c == 't' and escaping then
			sfuncCurrentArg = sfuncCurrentArg .. "\t"
		elseif escaping then
			warn(`Received unknown escape \"\\{c}\", ignoring backslash and treating as a normal character`)
			sfuncCurrentArg = sfuncCurrentArg .. c
		else
			sfuncCurrentArg = sfuncCurrentArg .. c
		end

		escaping = false
	end
	table.insert(sfuncArgs, sfuncCurrentArg)

	local sfuncExpectedType = table.remove(sfuncArgs, 1)
	local sfuncName = table.remove(sfuncArgs, 1)
	local sfunc = sfuncs[sfuncName]
	if sfunc == nil then
		warn(`SpecialFunc \"{sfuncName}\" not found!`)
		return false, nil
	end
	
	return true, {
		Func = sfunc,
		Name = sfuncName,
		Args = sfuncArgs,
		Type = sfuncExpectedType,
		Expr = sfuncContent
	}
end

function prefabSystem.EvaluateSpecFunc(prefab, element, sfuncData)
	local warn = warnLogger.new("SFuncExec", sfuncData.Expr, sfuncData.Name)
	
	local success, result = pcall(sfuncData.Func, prefab, element, unpack(sfuncData.Args))
	if success and typeof(result) == sfuncData.Type then return success, result end
	if not success then
		warn(`Execution failed with reason \"{result}\"`)
		return success, result
	end
	
	warn(`Executed successfully but did not return expected type {sfuncData.Type}`)
	return false, nil
end

apiConsumer.DoAPILoop(plugin, API_ID, prefabSystem.OnAPILoaded, prefabSystem.OnAPIUnloaded)]]></ProtectedString>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{2EFB673D-CAA3-471F-972B-512807FDA430}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Main</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXE3ED6761E617448D88CEFA079CA2B30F">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[--[[
	This module is provided for convenience of consumers of the serializer API
	providing a reference implementation for correctly retrieving and validating a reference to the API table

	For a working example of a plugin making use of this API via this module
	see: https://github.com/Sprixitite/InfiltrationEngine-PrefabSystem
]]

local coreGui = game:GetService("CoreGui")

export type Token = string
export type Hook = (...any) -> nil
export type HookType = "APIExtensionLoaded"|"APIExtensionUnloaded"|"PreSerialize"|"PreSerializeMissionSetup"|"SerializerUnloaded"
export type APIExtension = { [string] : (...any) -> ...any }

export type APIReference = {
	-- Generic
	GetAPIVersion 			: () -> number,
	GetCodeVersion 			: () -> number,
	GetAttributesMap 		: () -> { [string] : { [number] : any } },
	GetAttributeTypes 		: () -> { [string] : number },
	GetRegistrantFactory	: (author: string, plugin: string) -> ((hookName: string) -> string), 

	-- HookTypes
	GetHookTypes 			: () -> { [number] : string },
	IsHookTypeValid 		: (hookType: string, warnCaller: string?) -> boolean,

	-- Hooks
	AddHook 				: (hookType: HookType, registrant: string, hook: Hook, hookState: {any}?) -> Token,
	RemoveHook 				: (token: Token) -> nil,

	-- APIExtensions
	AddAPIExtension 		: (name: string, author: string, contents: APIExtension) -> Token,
	GetAPIExtension			: (name: string, author: string) -> APIExtension,
	RemoveAPIExtension		: (token: Token) -> nil
}

type AnyTbl = { [string] : any }

local APIConsumer = {}

local function ValidateArgTypes(fname: string, ...) : boolean
	local args = {...}
	for _, argSettings in ipairs(args) do
		local argName = argSettings[1]
		local argValue = argSettings[2]
		local argType = type(argValue)
		local argExpectedType = argSettings[3]
		if argType ~= argExpectedType then
			warn(`Invalid argument {argName} passed to function {fname} - expected type {argExpectedType} but got {argType}!`)
			return false
		end
	end
	return true
end

APIConsumer.ValidateArgTypes = ValidateArgTypes

-- Yields until timeOut is elapsed or API is found
APIConsumer.WaitForAPI = function(timeOut: number?) : APIReference?
	timeOut = if timeOut == nil then math.huge else timeOut

	if not ValidateArgTypes(
		"WaitForAPI",
		{"timeOut", timeOut, "number"}
		) then return end

	local presenceIndicator = coreGui:WaitForChild("InfilEngine_SerializerAPIAvailable", timeOut)
	if not presenceIndicator then return end

	local apiTbl = shared.InfilEngine_SerializerAPI
	if not (tostring(apiTbl) == presenceIndicator.Value) then return end

	return apiTbl
end

-- Attempt to get the API without blocking - returns false + nil if unavailable, otherwise returns true + APIReference
APIConsumer.TryGetAPI = function() : (boolean, APIReference?)
	local presenceIndicator = coreGui:FindFirstChild("InfilEngine_SerializerAPIAvailable")
	if not presenceIndicator then return false, nil end

	local apiTbl = shared.InfilEngine_SerializerAPI
	if not (tostring(apiTbl) == presenceIndicator.Value) then return false, nil end

	return true, apiTbl
end

-- Never returns unless there's an error
-- Continually wires up handling of serializer load/unload as well as unloading of consumer plugin as needed
-- Avoid doing this yourself if you can help it
APIConsumer.DoAPILoop = function<StateT>(
	callerPlugin: Plugin,
	srcname: string,
	loadedClbck: (api: APIReference, state: StateT) -> nil,
	unloadedClbck: (api: APIReference, state: StateT) -> nil, 
	state: StateT?
) : never
	state = if state == nil then {} else state

	if typeof(callerPlugin) ~= "Instance" then
		warn(`Invalid argument callerPlugin passed to DoAPILoop - expected type Plugin but got {typeof(callerPlugin)}!`)
		return
	end

	if callerPlugin.ClassName ~= "Plugin" then
		warn(`Invalid argument callerPlugin passed to DoAPILoop - expected type Plugin but got {callerPlugin.ClassName}!`)
		return
	end

	if not ValidateArgTypes(
		"DoAPILoop", 
		{"srcname", srcname, "string"},
		{"loadedClbck", loadedClbck, "function"},
		{"unloadedClbck", unloadedClbck, "function"},
		{"state", state, "table"}
		) then return end

	local api = APIConsumer.WaitForAPI()
	if api == nil then return APIConsumer.DoAPILoop(callerPlugin, srcname, loadedClbck, unloadedClbck, state) end

	loadedClbck(api, state)

	local pluginUnloadCallback
	local unloadToken

	pluginUnloadCallback = callerPlugin.Unloading:Connect(function()
		pluginUnloadCallback:Disconnect()
		pluginUnloadCallback = nil
		unloadedClbck(api, state)
		if unloadToken ~= nil then api.RemoveHook(unloadToken) end
	end)

	unloadToken = api.AddHook("SerializerUnloaded", `APIConsumerFramework_{srcname}`, function()
		if pluginUnloadCallback then pluginUnloadCallback:Disconnect() pluginUnloadCallback = nil end
		unloadedClbck(api, state)
		task.spawn(APIConsumer.DoAPILoop, callerPlugin, srcname, loadedClbck, unloadedClbck, state)
	end)
end

return APIConsumer]]></ProtectedString>
				<string name="ScriptGuid">{9C413FEA-27C9-4E1A-A9CC-E7239C0F162A}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">APIConsumer</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX3D84E76A357C4FA3A16A65B3C7BC42FF">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[--[[
	Slogger, yet another minimal Lua logging module
	Log function + post-init function are configurable, for dealing with the slog that is lua version compatibility
	
	Tested to be compatible with Lua5.1
	Presumed compatible with Lua5.2-5.5/Luajit/Luau
	
	© Sprixitite, 2025
]]

local slogger = {}

local sloggerCfg = {
	postInit = function(tbl) return tbl end,
	logFunc = print
}

local function varargs(...)
	local argCount = select('#', ...)
	local argTbl = { ... }
	local i = 0
	return function()
		i = i + 1
		if i <= argCount then return i, argTbl[i], argCount end
	end, argTbl
end

function slogger.new(...)
	local loggerPrefix = ""
	local varargsIter, argsTbl = varargs(...)
	
	for i, arg in varargsIter do
		loggerPrefix = loggerPrefix .. tostring(arg) .. " : "
	end
	
	local doWarn = function(tbl, ...)
		local finalMsg = ""
		
		for i, arg, argCount in varargs(...) do
			finalMsg = finalMsg .. tostring(arg)
			if i ~= argCount then
				finalMsg = finalMsg .. " : "
			end
		end
		
		sloggerCfg.logFunc(loggerPrefix .. finalMsg)
	end
	
	local specialize = function(...)
		return slogger.new(unpack(argsTbl), ...)
	end
	
	local newLogger = setmetatable({ specialize = specialize }, {__call = doWarn})
	return sloggerCfg.postInit(newLogger)
end

function slogger.init(cfg)
	for k, v in pairs(cfg) do
		if type(sloggerCfg[k]) == type(v) then
			sloggerCfg[k] = v
		end
	end
	return slogger
end

return slogger]]></ProtectedString>
				<string name="ScriptGuid">{9A026DAB-AF18-4CD8-98AE-F24BAF01A1ED}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Slogger</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX7A7F33AE968D4F9085E7C3EEC95E816F">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[local glut = require("./GLUt")

local LuaExpr = {}

local LUA_EXPR_BODY_STRMATCH = "([\\\'\"%-%+%*%^%.,:/_%w%s{}<>!=+|#]+)"

function LuaExpr.MakeEvalRules(prefix, delim)
	local bodyMatch = prefix .. LUA_EXPR_BODY_STRMATCH .. delim 
	return {
		BodyMatch = bodyMatch,
		SoleMatch = '^' .. bodyMatch .. '$'
	}
end

local LUA_EXPR_MATCH_DEFAULT = LuaExpr.MakeEvalRules("%$%(", "%)")

function LuaExpr.IsSoleExpr(str, rules)
	local soleExprData = string.match(str, rules.SoleMatch)
	return soleExprData ~= nil, soleExprData
end

function LuaExpr.EvalSoleExpr(str, fenv, rules, exprName, multiRet)
	exprName = glut.default_typed(exprName, "LUAEXPR_UNNAMED", "exprName", "LuaExpr.EvalSoleExpr")
	multiRet = glut.default_typed(multiRet, false, "multiRet", "LuaExpr.EvalSoleExpr")
	
	local leadingReturn = string.match(str, "^return%s+")
	if leadingReturn == nil then str = "return " .. str end
	
	local success, count, args = glut.str_runlua(str, fenv, exprName)
	if not success then
		return false, "LuaExpr : " .. exprName .. " : Evaluation failed : " .. count
	end
	
	return success, args[1]
end

function LuaExpr.Eval(str, fenv, rules, exprName, soleOnly)
	if not glut.type_check(str, "string", "str", "LuaExpr.Eval") then return end
	if not glut.type_check(fenv, "table", "fenv", "LuaExpr.Eval") then return end
	
	rules = glut.default_typed(rules, LUA_EXPR_MATCH_DEFAULT, "rules", "LuaExpr.Eval")
	exprName = glut.default_typed(exprName, "LUAEXPR_UNNAMED", "epxrName", "LuaExpr.Eval")
	soleOnly = glut.default_typed(soleOnly, false, "soleOnly", "LuaExpr.Eval")
	
	local isSole, soleData = LuaExpr.IsSoleExpr(str, rules)
	if isSole then return LuaExpr.EvalSoleExpr(soleData, fenv, rules, exprName, isSole) end
	if soleOnly then return false, nil end
	
	local i = 0
	return true, string.gsub(str, rules.BodyMatch, function(subexpr)
		i = i+1
		local subExprName = exprName .. '#' .. tostring(i)
		local evalSuccess, evalVal = LuaExpr.EvalSoleExpr(subexpr, fenv, rules, subExprName, false)
		return tostring(evalVal)
	end)
end

return LuaExpr]]></ProtectedString>
				<string name="ScriptGuid">{DE119178-750B-474C-BF0B-A605B90864FB}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">LuaExpr</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX5939D6A997BC4CB18A22A9FA720EB377">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[--[[
	GLUt // GoodLuaUtilities // Lua5.1 utilities module
	
	© Sprixitite, 2025
]]

local GLUt = {}

local GLUtCfg = {
	print = print,
	warn  = function(...) print("WARNING", ...) end,
	error = error,
	type  = type
}

local patternSpecChars = { '(', ')', '.', '%', '+', '-', '*', '?', '[', ']', '^', '$' }

GLUt.severity = {
	SILENT = 0,
	LOG = 1,
	WARN = 2,
	ERR = 3,
	ERROR = 3
}

local function severity_warn(sev, ...)
	if sev == GLUt.severity.SILENT then return end
	local warn_fn
	if sev == GLUt.severity.LOG then
		warn_fn = GLUtCfg.print
	elseif sev == GLUt.severity.WARN then
		warn_fn = GLUtCfg.warn
	else
		warn_fn = GLUtCfg.error
	end
	warn_fn(...)
end

function GLUt.configure(tbl)
	for k, v in pairs(tbl) do
		if GLUtCfg[k] ~= nil then
			GLUtCfg[k] = v
		else
			GLUtCfg.warn("Attempt to set invalid GLUtCfg Key \"" .. tostring(k) .. "\"")
		end
	end
end

function GLUt.custom_iter(tbl, keys)
	local i = 0
	return function()
		i = i + 1
		local requested = {}
		local iTbl = tbl[i]
		if iTbl == nil then return nil end
		for ki, k in ipairs(keys) do
			requested[ki] = iTbl[k]
		end 
		return i, unpack(requested)
	end
end

function GLUt.custom_iter_template(...)
	local varargs = { ... }
	return function(tbl) return GLUt.custom_iter(tbl, varargs) end
end

function GLUt.default(arg, default)
	return (arg == nil) and default or arg
end

function GLUt.default_exec(arg, fn)
	return (arg == nil) and fn() or arg
end

function GLUt.default_bounds(arg, default, min, max)
	if arg == nil then return default end
	if arg < min then return default end
	if max < arg then return default end
	return arg
end

function GLUt.default_typed(arg, default, argName, funcName)
	local argType = GLUtCfg.type(arg)
	local defaultType = GLUtCfg.type(default)
	if argType == defaultType then return arg end
	if argType == "nil" then return default end
	GLUt.type_warn(argName, funcName, defaultType, argType)
	return default
end

function GLUt.type_warn(argName, funcName, expected, got, severity)
	if argName == nil or expected == got then return end
	if type(severity) == "boolean" then
		severity = severity and GLUt.severity.ERROR or GLUt.severity.WARN 
	end
	severity = GLUt.default_bounds(severity, GLUt.severity.ERROR, GLUt.severity.SILENT, GLUt.severity.ERROR)

	local warnStart = GLUt.type_is(funcName, "string") and (funcName .. ": expected arg \"") or "Expected arg \""
	severity_warn(severity, warnStart .. argName .. "\" of type \"" .. expected .. "\" got type \"" .. got .. "\"!")
	severity_warn(severity, "Traceback: " .. debug.traceback())
end

function GLUt.type_check(arg, expected, argName, funcName, severity)
	local argType = GLUtCfg.type(arg)

	expected = string.gsub(expected, '?', "|nil")
	for _, validType in pairs(GLUt.str_split(expected, '|')) do
		if validType == argType then return true end
	end

	GLUt.type_warn(argName, funcName, expected, argType, severity)

	return false
end

function GLUt.type_is(a1, t)
	return GLUtCfg.type(a1) == t
end

function GLUt.type_eq(a1, a2)
	return GLUtCfg.type(a1) == GLUtCfg.type(a2)
end

function GLUt.vararg_capture(...)
	local n = select('#', ...)
	return n, { ... }
end

function GLUt.vararg_iter(...)
	local n, t = GLUt.vararg_capture(...)
	local i = 0
	return function()
		i = i + 1
		if i <= n then return i, t[i], n end
	end, t
end

function GLUt.str_split(str, separator)
	str = str .. separator
	separator = GLUt.str_escape_pattern(separator)

	local substrs = {}
	for substr in string.gmatch(str, "(.-)" .. separator) do
		substrs[#substrs+1] = substr
	end
	return substrs
end

function GLUt.str_has_match(str, pattern)
	return string.match(str, pattern) ~= nil
end

function GLUt.str_escape_pattern(str)
	local escaped = str
	for _, specChar in ipairs(patternSpecChars) do
		local escapedSpec = '%' .. specChar
		escaped = string.gsub(escaped, escapedSpec, (specChar == '%') and "%%" or '%' .. escapedSpec)
	end
	return escaped
end

function GLUt.str_double_substr(str, substr)
	local safe = GLUt.str_escape_pattern(substr)
	return string.gsub(str, safe, safe .. safe)
end

function GLUt.str_isempty(str)
	return string.match(str, "^%s$") ~= nil
end

function GLUt.str_chariter(str)
	local n = #str
	local i = 0
	return function()
		i = i + 1
		if i <= n then return GLUt.str_getchar(str, i) end
	end
end

function GLUt.str_trim(str, pattern)
	pattern = GLUt.default(pattern, "%s")
	return GLUt.str_trimend(GLUt.str_trimstart(str, pattern), pattern)
end

function GLUt.str_trimstart(str, pattern)
	pattern = GLUt.default(pattern, "%s")
	return string.gsub(str, '^' .. pattern, "")
end

function GLUt.str_trimend(str, pattern)
	pattern = GLUt.default(pattern, "%s")
	return string.gsub(str, pattern .. '$', "")
end

function GLUt.str_getchar(str, i)
	return string.sub(str, i, i)
end

local unidentified = -1
function GLUt.str_runlua(source, fenv, chunkName)
	chunkName = GLUt.default_exec(chunkName, function()
		unidentified = unidentified + 1
		return "loadstring#" .. tostring(unidentified) 
	end)

	local strFun, failReason = loadstring(source, chunkName)
	if GLUtCfg.type(strFun) ~= "function" then
		return false, "Loadstring : " .. chunkName .. " : Evaluation failed : " .. failReason
	end

	strFun = setfenv(strFun, fenv)

	return pcall(function()
		return GLUt.vararg_capture(strFun())
	end)
end

function GLUt.str_runlua_unsafe(source, chunkName)
	local strFun, failReason = loadstring(source, chunkName)
	if GLUtCfg.type(strFun) ~= "function" then
		return false, "Loadstring : " .. chunkName .. " : Evaluation failed : " .. failReason
	end

	return pcall(function()
		return GLUt.vararg_capture()
	end)
end

function GLUt.kvp_tostring(k, v)
	return tostring(k) .. " = " .. tostring(v)
end

function GLUt.tbl_tryindex(tbl, ...)
	local indexing = tbl
	for _, k in GLUt.vararg_iter(...) do
		if GLUtCfg.type(indexing) ~= "table" then
			return false, indexing
		end
		indexing = indexing[tostring(k)]
	end

	return true, indexing
end

function GLUt.tbl_deepget(tbl, create_missing, ...)
	local indexing = tbl
	for i, k, n in GLUt.vararg_iter(...) do
		k = tostring(k)

		if indexing[k] == nil and create_missing then
			indexing[k] = {}
		end

		indexing = indexing[k]
		if GLUtCfg.type(indexing) ~= "table" and not (i == n) then
			return false, indexing, k
		end
	end

	return true, indexing
end

function GLUt.tbl_getkeys(tbl)
	local keys = {}
	for k, _ in pairs(tbl) do keys[#keys+1] = k end
	return keys
end

function GLUt.tbl_clone(tbl, shallow)
	shallow = GLUt.default(shallow, false)

	local cloned = {}
	for k, v in pairs(tbl) do
		if GLUtCfg.type(v) == "table" and not shallow then
			cloned[k] = GLUt.tbl_clone(v, shallow)
		else
			cloned[k] = v
		end
	end
	return cloned
end

function GLUt.tbl_merge(tbl1, tbl2, priority)
	priority = GLUt.default(priority, 1)
	local secondPriority = priority == 2
	local merged = {}
	for k, v in pairs(tbl1) do
		merged[k] = v
	end
	for k, v in pairs(tbl2) do
		local existing = merged[k]
		if GLUtCfg.type(existing) == "table" then
			merged[k] = GLUt.tbl_merge(existing, v, priority)
		elseif existing ~= nil and secondPriority then
			merged[k] = v
		elseif merged[k] == nil then
			merged[k] = v
		end
	end
	return merged
end

function GLUt.tbl_findsize(tbl)
	local i = 0
	for _, _ in pairs(tbl) do i = i + 1 end
	return i
end

local function tbl_tostring(tblName, tbl, levels, level)
	local str = tblName .. " = {"
	local indent = string.rep("  ", level)
	local n = GLUt.tbl_findsize(tbl)
	local i = 0
	for k, v in pairs(tbl) do
		i = i + 1
		str = str .. '\n' .. indent
		if GLUtCfg.type(v) == "table" and levels > level then
			str = str .. tbl_tostring(k, v, levels, level+1)
		else
			str = str .. GLUt.kvp_tostring(k, v)
		end
		if i < n then str = str .. ',' end
	end
	return str
end

function GLUt.tbl_tostring(tbl, levels, tblName)
	GLUt.default(tblName, tostring(tbl))
	return tbl_tostring(tblName, tbl, levels, 1)
end

function GLUt.tbl_any(tbl, f)
	local anySucceed = nil
	for k, v in pairs(tbl) do
		anySucceed = GLUt.default(anySucceed, false) or f(k, v)
		if anySucceed then break end
	end
	return anySucceed
end

function GLUt.tbl_all(tbl, f)
	local allSucceed = nil
	for k, v in pairs(tbl) do
		allSucceed = GLUt.default(allSucceed, true) and f(k, v)
		if not allSucceed then break end
	end
	return allSucceed
end

function GLUt.tbl_is_arr(tbl)
	local isArr = true
	for k, v in pairs(tbl) do
		isArr = isArr and GLUtCfg.type(k) == "number"
		if not isArr then break end
	end
	return isArr
end

local function tbl_arginfo(argType, name, index, expectedType)
	local typeStr = GLUt.type_is(expectedType, "string") and (" <T:" .. expectedType .. ">") or ""
	return argType .. " \"" .. name .. "\" (#" .. tostring(index) .. ")" .. typeStr 
end

local function tbl_argextract(fname, t, arglayout)
	local index = arglayout[1]
	local name = arglayout[2]
	local expectedType = arglayout[3]
	local canName = arglayout[4]
	local default = arglayout.Default or arglayout.default
	local vital = GLUt.default(arglayout.Vital or arglayout.vital, false)

	local tVal = t[index]
	if canName and tVal ~= nil then
		if t[name] ~= nil then
			return GLUtCfg.error(fname .. "@tblcall : " .. tbl_arginfo("Arg", name, index, expectedType) .. " passed both by name and index!")
		end
	elseif canName then
		tVal = t[name]
	end

	if tVal == nil and default ~= nil then
		tVal = default
	end

	if tVal == nil and expectedType == false then
		return nil
	elseif tVal == nil and not GLUt.str_has_match(expectedType, "%?") then
		local argType = vital and "Vital Arg" or "Arg"
		return GLUtCfg.error(fname .. "@tblcall : " .. tbl_arginfo(argType, name, index, expectedType) .. " not passed!")
	end

	if expectedType == false then return tVal end
	if not GLUt.type_check(tVal, expectedType, name, fname, true) then return nil end
	return tVal
end

function GLUt.fun_tblcallable(fname, f, ...)
	local n, callingConvention = GLUt.vararg_capture(...)
	return function(tbl)
		for k, v in pairs(tbl) do
			local isValid = false
			for i=1, n do
				if isValid then break end
				local validArg = callingConvention[i]
				isValid = (k == i) or (k == validArg[2])
			end
			if not isValid then
				GLUtCfg.error("Received unexpected argument \"" .. tostring(k) .. "\" of type \"" .. GLUtCfg.type(v) .. "\"!")
			end
		end
		local args = {}
		for i=1, n do
			local argLayout = callingConvention[i]
			args[i] = tbl_argextract(fname, tbl, argLayout)
		end
		return f(unpack(args, 1, n))
	end
end

return GLUt]]></ProtectedString>
				<string name="ScriptGuid">{7484DC6C-C136-46C9-992B-BD6809BF968D}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">GLUt</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX99CD90B9F69D4683BE8907878DB73707">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[local glut = require("./GLUt")

local luaExprFuncs = {}

local function StaticGroupErr(groupName)
	error("Attempt to set StaticStateGroup " .. groupName .. " but encountered non-table element!")
end

local function returnArgs(...) return ... end

local function ExprFunc(fname, f, ...)
	local tblCallable = glut.fun_tblcallable(fname, returnArgs, ...)
	return function(inst, state, staticState, t)
		return f(inst, state, staticState, tblCallable(t))
	end
end

local function ExprFuncOverload(fname, f, foverloading, ...)
	local tblCallable = glut.fun_tblcallable(fname, returnArgs, ...)
	return function(inst, state, staticState, t)
		local overloaded = function() return foverloading(inst, state, staticState, t) end
		return f(inst, state, staticState, overloaded, tblCallable(t))
	end
end

luaExprFuncs.setAttributes = ExprFunc(
	"setAttributes",
	function(inst, state, staticState, attrs)
		for k, v in pairs(attrs) do
			inst:SetAttribute(k, v)
		end
		return true
	end,
	{ 1, "attributes", "table", false, vital=true }
)

luaExprFuncs.setStateValue = ExprFunc(
	"setStateValues",
	function(inst, state, staticState, name, value)
		if state[name] ~= nil then
			error("Attempt to set already-existing StateValue \"" .. name .. "\"!")
		end 
		state[name] = value
		return true
	end,
	{ 1, "name", "string", false, vital=true },
	{ 2, "value", false, false, vital=true }
)

luaExprFuncs.stringSplit = ExprFunc(
	"stringSplit",
	function(inst, state, staticState, value, separator)
		return glut.str_split(value, separator)
	end,
	{ 1, "value", "string", false, vital=true },
	{ 2, "separator", "string", false, vital=true }
)

luaExprFuncs.unpackToState = ExprFunc(
	"unpackToState",
	function(inst, state, staticState, unpacking, ...)
		local locTbl = { ... }
		for i, v in ipairs(unpacking) do
			local locPath = locTbl[i]
			if locPath == nil then break end
			local unpackPath = glut.str_split(locPath, '.')
			local unpackLast = table.remove(unpackPath)
			local success, unpackTbl = glut.tbl_deepget(state, true, unpack(unpackPath))
			if not success then StaticGroupErr(locPath) end
			unpackTbl[unpackLast] = v
		end
		return true
	end,
	-- Ugly hack
	-- You get 16 unpack locations, use em wisely
	{  1, "unpacking", "table", false, vital=true },
	{  2, "state#1", "string", false, vital=true },
	{  3, "state#2", "string?", false, default=nil },
	{  4, "state#3", "string?", false, default=nil },
	{  5, "state#4", "string?", false, default=nil },
	{  6, "state#5", "string?", false, default=nil },
	{  7, "state#6", "string?", false, default=nil },
	{  8, "state#7", "string?", false, default=nil },
	{  9, "state#8", "string?", false, default=nil },
	{ 10, "state#9", "string?", false, default=nil },
	{ 11, "state#10", "string?", false, default=nil },
	{ 12, "state#11", "string?", false, default=nil },
	{ 13, "state#12", "string?", false, default=nil },
	{ 14, "state#13", "string?", false, default=nil },
	{ 15, "state#14", "string?", false, default=nil },
	{ 16, "state#15", "string?", false, default=nil },
	{ 17, "state#16", "string?", false, default=nil }
)

luaExprFuncs.staticGroupToLocalArray = ExprFunc(
	"staticGroupToLocalArray",
	function(inst, state, staticState, groupName, elementPrefix, stateScriptAccess)
		local groupPath = glut.str_split(groupName, '.')
		local success, groupTbl = glut.tbl_deepget(state, unpack(groupPath))
		if not success then StaticGroupErr(groupName) end
		inst:SetAttribute(elementPrefix .. "Count", #groupTbl)
		local statescriptAccessor = "INIT #StateScriptAccessLocalArrayTemp 0"
		for i, v in ipairs(groupTbl) do
			statescriptAccessor = statescriptAccessor .. "\n SET #StateScriptAccessLocalArrayTemp #" .. elementPrefix .. tostring(i) 
			inst:SetAttribute(elementPrefix .. tostring(i), v)
		end
		if stateScriptAccess ~= "NO!" then
			inst:SetAttribute(stateScriptAccess, statescriptAccessor)
		end
		return true
	end,
	{ 1, "groupName", "string", false, vital=true },
	{ 2, "elementPrefix", "string", false, vital=true },
	{ 3, "stateScriptAccess", "string", true, default="NO!" }
)

luaExprFuncs.importStaticGroup = ExprFunc(
	"importStaticGroup",
	function(inst, state, staticState, groupName, importLocation, allowDuplicates)
		local importPath = glut.str_split(importLocation, '.')
		local importKey = table.remove(importPath)
		local success, importTbl = glut.tbl_deepget(state, true, unpack(importPath))
		if not success then StaticGroupErr(importPath) end
		if importTbl[importKey] ~= nil then return end
		local groupPath = glut.str_split(groupName, '.')
		local success, groupTbl = glut.tbl_deepget(staticState, false, unpack(groupPath))
		if not success then StaticGroupErr(groupName) end
		groupTbl = glut.tbl_clone(groupTbl, false)
		if not allowDuplicates then
			local noDupes = {}
			for k, v in pairs(groupTbl) do
				if table.find(noDupes, v) ~= nil then continue end
				if type(k) == "number" then table.insert(noDupes, v) continue end
				noDupes[k] = v
			end
			groupTbl = noDupes
		end
		importTbl[importKey] = groupTbl
		return true
	end,
	{ 1, "groupName", "string", false, vital=true },
	{ 2, "importLocation", "string", false, vital=true },
	{ 3, "allowDuplicates", "boolean", true, default=true }
)

luaExprFuncs.staticGroupExport = ExprFunc(
	"staticGroupExport",
	function(inst, state, staticState, groupName, exportValue, allowDuplicates)
		-- Exports a variable as a member of a staticState group, creating the group if it does not exist
		local groupPath = glut.str_split(groupName, '.')
		local success, groupTbl = glut.tbl_deepget(staticState, true, unpack(groupPath))
		if not success then StaticGroupErr(groupName) end
		if not allowDuplicates then
			if table.find(groupTbl, exportValue) then return exportValue end
		end
		table.insert(groupTbl, exportValue)
		return exportValue
	end,
	{ 1, "groupName", "string", false, vital=true },
	{ 2, "exportValue", false, false, vital=true },
	{ 3, "allowDuplicates", "boolean", true, default=false }
)

luaExprFuncs.staticGroupCombine = ExprFunc(
	"staticGroupCombine",
	function(
		inst, state, staticState,
		groupName,
		combineOp,
		prefix,
		suffix,
		field,
		itemPrefix,
		itemSuffix,
		autoBrackets
	)
		-- Concatenates the string representation of all members of a staticState group, using the specified operator inbetween all elements
		local groupPath = glut.str_split(groupName, '.')
		local success, groupTbl = glut.tbl_deepget(staticState, false, unpack(groupPath))
		if not success then StaticGroupErr(groupName) end
		local openBracket = autoBrackets and "(" or ""
		local closeBracket = autoBrackets and ")" or ""
		local str = prefix .. openBracket
		for i, v in ipairs(groupTbl) do
			if i ~= 1 then str = str .. combineOp end
			local vStr = (field == nil) and tostring(v) or tostring(v[field])
			str = str .. itemPrefix .. vStr .. itemSuffix
		end
		str = str .. closeBracket .. suffix
		return str
	end,
	{ 1, "groupName", "string", false, vital=true },
	{ 2, "combineOp", "string", false, vital=true },
	{ 3, "prefix", "string", true, default="" },
	{ 4, "suffix", "string", true, default="" },
	{ 5, "field", false, true, default=nil },
	{ 6, "itemPrefix", "string", true, default="" },
	{ 7, "itemSuffix", "string", true, default="" },
	{ 8, "autoBrackets", "boolean", true, default=true }
)

luaExprFuncs.staticGroupEmpty = ExprFunc(
	"staticGroupEmpty",
	function(inst, state, staticState, groupName, quietFail)
		-- Returns true if the StaticStateGroup at the given path is empty
		return luaExprFuncs.staticGroupSize(inst, state, staticState, { groupName, quietFail=quietFail }) == 0
	end,
	{ 1, "groupName", "string", false, vital=true },
	{ 2, "quietFail", "boolean", true, default=false }
) 

luaExprFuncs.staticGroupSize = ExprFunc( 
	"staticGroupSize",
	function(inst, state, staticState, groupName, asString, quietFail)
		-- Returns the size of the StaticStateGroup at the given path - optionally as a string
		local groupPath = glut.str_split(groupName, '.')
		local success, groupTbl = glut.tbl_deepget(staticState, false, unpack(groupPath))
		if not success and not quietFail then
			StaticGroupErr(groupName)
		elseif not success then
			return 0
		end
		return (asString and tostring(#groupTbl)) or #groupTbl
	end,
	{ 1, "groupName", "string", false, vital=true },
	{ 2, "asString", "boolean", true, default=false },
	{ 3, "quietFail", "boolean", true, default=false }
)

luaExprFuncs.moveFirstStaticElement = ExprFunc(
	"moveFirstStaticElement",
	function(
		inst, state, staticState,
		groupName,
		destName,
		pairItem,
		quietFail
	)
		-- Removes the first element of the StaticStateGroup at the given path, and places it
		if pairItem ~= 'k' and pairItem ~= 'v' then error("pairItem must be nil|\"k\"|\"v\"!") end
		local groupPath = glut.str_split(groupName, '.')
		local destPath = glut.str_split(destName, '.')
		local destKey = table.remove(destPath, #destPath)
		local success, groupTbl = glut.tbl_deepget(staticState, false, unpack(groupPath))
		if not success then StaticGroupErr(groupName) end
		local success, destTbl = glut.tbl_deepget(staticState, true, unpack(destPath))
		if not success then StaticGroupErr(destName) end
		local groupKeys = glut.tbl_getkeys(groupTbl)
		local firstKey = groupKeys[1]
		if firstKey == nil and quietFail then return true end
		local moving = nil
		if type(firstKey) == "number" then 
			moving = table.remove(groupTbl, firstKey)
		else 
			moving = groupTbl[firstKey]
			groupTbl[firstKey] = nil 
		end
		if pairItem == 'k' then moving = firstKey end
		destTbl[destKey] = moving
		return true
	end,
	{ 1, "groupName", "string", false, vital=true },
	{ 2, "destinationName", "string", false, vital=true },
	{ 3, "pairItem", "string", true, default="v" },
	{ 4, "quietFail", "boolean", true, default=false }
)

luaExprFuncs.getStaticVariable = ExprFunc( 
	"getStaticVariable",
	function(inst, state, staticState, varName)
		local varPath = glut.str_split(varName, '.')
		local varKey = table.remove(varPath, #varPath)
		local success, varTbl = glut.tbl_deepget(staticState, false, unpack(varPath))
		if not success then StaticGroupErr(varName) end
		return varTbl[varKey]
	end,
	{ 1, "varName", "string", false, vital=true }
)

luaExprFuncs.fallbackIfUnset = ExprFunc(
	"fallbackIfUnset",
	function(inst, state, staticState, maybeUnset, fallback)
		-- Returns the second argument if the first contains the substring "UNSET" (case-sensitive)
		if maybeUnset == nil then return fallback end
		if type(maybeUnset) ~= "string" then return maybeUnset end
		if glut.str_has_match(maybeUnset, "UNSET") then return fallback end
		if glut.str_has_match(maybeUnset, "DEFAULT") then return fallback end
		return maybeUnset
	end,
	{ 1, "maybeUnset", false, false, default=nil },
	{ 2, "fallback", false, false, default=nil }
)

-- Convenience if you forget the name
luaExprFuncs.fallbackIfDefault = ExprFuncOverload(
	"fallbackIfDefault",
	function(inst, state, staticState, overload, maybeUnset, fallback)
		return overload()
	end,
	{ 1, "maybeUnset", false, false, default=nil },
	{ 2, "fallback", false, false, default=nil }
)

luaExprFuncs.CreateExprFenv = function(inst, instState, staticState, globalState)
	return setmetatable(
		{},
		{
			__index = function(t, k)
				if instState[k] ~= nil then return instState[k] end
				if k == "Global" or k == "Globals" then return globalState end
				if luaExprFuncs[k] == nil then return nil end
				return function(t)
					return luaExprFuncs[k](inst, instState, staticState, t)
				end
			end,
		}
	)
end

return luaExprFuncs]]></ProtectedString>
				<string name="ScriptGuid">{E2794CDD-4304-468F-9705-C61F2BB5BBDA}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">LuaExprFuncs</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXE188EF383D304E06AC52F9D5811BC0B6">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[local glut = require("./GLUt")
local exprFuncs = require("./LuaExprFuncs")

local ShebangFuncs = {}

ShebangFuncs.CreateShebangFenv = function(inst, state, staticState, globalState)
	local tableLib = glut.tbl_clone(table)
	local stringLib = glut.tbl_clone(string)

	stringLib.split = glut.str_split
	tableLib.getkeys = glut.tbl_getkeys
	
	local luaExprFuncs = setmetatable(
		{},
		{
			__index = function(tbl, k)
				return function(targs)
					return exprFuncs[k](inst, state, staticState, targs)
				end
			end,
		}
	)
	
	local fenvBase = {
		exprFuncs = luaExprFuncs,
		luaExprFuncs = luaExprFuncs,
		global = globalState,
		globals = globalState,
		globalState = globalState,
		state = state,
		static = staticState,
		staticState = staticState,
		math = math,
		table = tableLib,
		string = stringLib,
		CFrame = CFrame,
		Color3 = Color3,
		Vector2 = Vector2,
		Vector3 = Vector3,
		tostring = tostring,
		tonumber = tonumber,
		pairs = pairs,
		ipairs = ipairs,
		next = next,
		print = print,
		unpack = unpack,
		setAttributes = function(t) for k, v in pairs(t) do inst:SetAttribute(k, v) end return true end
	}

	-- state can't overshadow builtin libraries
	setmetatable(
		fenvBase,
		{ __index = state }
	)
	return fenvBase
end

return ShebangFuncs
]]></ProtectedString>
				<string name="ScriptGuid">{78862712-3172-4A70-8B65-D07D67618659}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">ShebangFuncs</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX6AF5E70D0C8B4AC98B7D8024179FD406">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[return {
	FolderPath 		= { "PrefabInstances" },
	ValidClasses 	= { "BasePart" },
	ImportsGlobals 	= false,
	FolderRelation 	= "descendant",
	TypeIsAttribute = "PrefabName"
}]]></ProtectedString>
				<string name="ScriptGuid">{40183D36-6F16-44E7-AF38-F9E87356718B}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">AttributeImporterSearchInfo</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
</roblox>